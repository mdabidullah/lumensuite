{"version":3,"file":"getter.js","sourceRoot":"","sources":["../../../src/utils/model/getter.ts"],"names":[],"mappings":"AAGA,OAAO,EAAuB,eAAe,EAAE,MAAM,0BAA0B,CAAC;AAEhF,OAAO,EAAE,aAAa,EAAE,MAAM,cAAc,CAAC;AAE7C,MAAM,UAAU,iBAAiB,CAC/B,KAAiB,EACjB,KAAiC;IAEjC,IAAI,QAAQ,GAAsB,KAAK,CAAC;IACxC,OAAO,QAAQ,EAAE,CAAC;QAChB,IAAI,KAAK,CAAC,QAAQ,CAAC,EAAE,CAAC;YACpB,OAAO,QAAQ,CAAC;QAClB,CAAC;QACD,QAAQ,GAAG,QAAQ,CAAC,MAAM,CAAC;IAC7B,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC;AAED;;;GAGG;AACH,MAAM,CAAC,KAAK,UAAU,sBAAsB,CAC1C,UAAsB,EACtB,EAAU;IAEV,MAAM,WAAW,GAAG,UAAU,CAAC,GAAG,CAAC,IAAI,EAAE,EAAE,CAAC;IAC5C,IAAI,CAAC,WAAW;QAAE,OAAO,IAAI,CAAC;IAC9B,MAAM,aAAa,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,CAAC,CAAC;IAC5D,IAAI,CAAC,aAAa;QAAE,OAAO,IAAI,CAAC;IAChC,MAAM,aAAa,CAAC,cAAc,CAAC;IAEnC,OAAO,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC;AACtC,CAAC;AAED,MAAM,UAAU,kBAAkB,CAAC,KAAiB;IAClD,OAAO,iBAAiB,CAAC,KAAK,EAAE,CAAC,CAAC,EAAE,CAClC,aAAa,CAAC,CAAC,EAAE,CAAC,aAAa,CAAC,CAAC,CACT,CAAC;AAC7B,CAAC;AAED,MAAM,UAAU,gBAAgB,CAAC,GAAQ;IACvC,IAAI,IAAI,GAA0B,IAAI,CAAC;IACvC,IAAI,CAAC,GAAG,CAAC,IAAI;QAAE,OAAO,IAAI,CAAC;IAC3B,MAAM,EAAE,QAAQ,EAAE,GAAG,GAAG,CAAC,IAAI,CAAC;IAC9B,KAAK,IAAI,CAAC,GAAG,QAAQ,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,IAAI,CAAC,EAAE,CAAC,EAAE,EAAE,CAAC;QAC9C,MAAM,KAAK,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;QAC1B,IACE,aAAa,CAAC,KAAK,EAAE,CAAC,aAAa,CAAC,CAAC;YACrC,KAAK,CAAC,WAAW,KAAK,eAAe,CAAC,YAAY,EAClD,CAAC;YACD,IAAI,GAAG,KAAuB,CAAC;YAC/B,MAAM;QACR,CAAC;IACH,CAAC;IACD,OAAO,IAAI,CAAC;AACd,CAAC","sourcesContent":["import type { BlockComponent, EditorHost } from '@lumensuite/block-std';\nimport type { BlockModel, Doc } from '@lumensuite/store';\n\nimport { type NoteBlockModel, NoteDisplayMode } from '@lumensuite/affine-model';\n\nimport { matchFlavours } from './checker.js';\n\nexport function findAncestorModel(\n  model: BlockModel,\n  match: (m: BlockModel) => boolean\n) {\n  let curModel: BlockModel | null = model;\n  while (curModel) {\n    if (match(curModel)) {\n      return curModel;\n    }\n    curModel = curModel.parent;\n  }\n  return null;\n}\n\n/**\n * Get block component by its model and wait for the doc element to finish updating.\n *\n */\nexport async function asyncGetBlockComponent(\n  editorHost: EditorHost,\n  id: string\n): Promise<BlockComponent | null> {\n  const rootBlockId = editorHost.doc.root?.id;\n  if (!rootBlockId) return null;\n  const rootComponent = editorHost.view.getBlock(rootBlockId);\n  if (!rootComponent) return null;\n  await rootComponent.updateComplete;\n\n  return editorHost.view.getBlock(id);\n}\n\nexport function findNoteBlockModel(model: BlockModel) {\n  return findAncestorModel(model, m =>\n    matchFlavours(m, ['affine:note'])\n  ) as NoteBlockModel | null;\n}\n\nexport function getLastNoteBlock(doc: Doc) {\n  let note: NoteBlockModel | null = null;\n  if (!doc.root) return null;\n  const { children } = doc.root;\n  for (let i = children.length - 1; i >= 0; i--) {\n    const child = children[i];\n    if (\n      matchFlavours(child, ['affine:note']) &&\n      child.displayMode !== NoteDisplayMode.EdgelessOnly\n    ) {\n      note = child as NoteBlockModel;\n      break;\n    }\n  }\n  return note;\n}\n"]}