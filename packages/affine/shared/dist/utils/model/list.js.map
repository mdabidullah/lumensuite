{"version":3,"file":"list.js","sourceRoot":"","sources":["../../../src/utils/model/list.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ListBlockModel } from '@blocksuite/affine-model';\nimport type { BlockStdScope } from '@blocksuite/block-std';\nimport type { BlockModel, Doc } from '@blocksuite/store';\n\nimport { matchFlavours } from './checker.js';\n\n/**\n * Pass in a list model, and this function will look forward to find continuous sibling numbered lists,\n * typically used for updating list numbers. The result not contains the list passed in.\n */\nexport function getNextContinuousNumberedLists(\n  doc: Doc,\n  modelOrId: BlockModel | string\n): ListBlockModel[] {\n  const model =\n    typeof modelOrId === 'string' ? doc.getBlock(modelOrId)?.model : modelOrId;\n  if (!model) return [];\n  const parent = doc.getParent(model);\n  if (!parent) return [];\n  const modelIndex = parent.children.indexOf(model);\n  if (modelIndex === -1) return [];\n\n  const firstNotNumberedListIndex = parent.children.findIndex(\n    (model, i) =>\n      i > modelIndex &&\n      (!matchFlavours(model, ['affine:list']) || model.type !== 'numbered')\n  );\n  const newContinuousLists = parent.children.slice(\n    modelIndex + 1,\n    firstNotNumberedListIndex === -1 ? undefined : firstNotNumberedListIndex\n  );\n  if (\n    !newContinuousLists.every(\n      model =>\n        matchFlavours(model, ['affine:list']) && model.type === 'numbered'\n    )\n  )\n    return [];\n\n  return newContinuousLists as ListBlockModel[];\n}\n\nexport function toNumberedList(\n  std: BlockStdScope,\n  model: BlockModel,\n  order: number\n) {\n  const { doc } = std;\n  if (!model.text) return;\n  const parent = doc.getParent(model);\n  if (!parent) return;\n  const index = parent.children.indexOf(model);\n  const prevSibling = doc.getPrev(model);\n  let realOrder = order;\n\n  // if there is a numbered list before, the order continues from the previous list\n  if (\n    prevSibling &&\n    matchFlavours(prevSibling, ['affine:list']) &&\n    prevSibling.type === 'numbered'\n  ) {\n    doc.transact(() => {\n      if (!prevSibling.order) prevSibling.order = 1;\n      realOrder = prevSibling.order + 1;\n    });\n  }\n\n  // add a new list block and delete the current block\n  const newListId = doc.addBlock(\n    'affine:list',\n    {\n      type: 'numbered',\n      text: model.text.clone(),\n      order: realOrder,\n    },\n    parent,\n    index\n  );\n  const newList = doc.getBlock(newListId)?.model;\n  if (!newList) {\n    return;\n  }\n\n  doc.deleteBlock(model, {\n    deleteChildren: false,\n    bringChildrenTo: newList,\n  });\n\n  // if there is a numbered list following, correct their order to keep them continuous\n  const nextContinuousNumberedLists = getNextContinuousNumberedLists(\n    doc,\n    newList\n  );\n  let base = realOrder + 1;\n  nextContinuousNumberedLists.forEach(list => {\n    doc.transact(() => {\n      list.order = base;\n    });\n    base += 1;\n  });\n\n  return newList.id;\n}\n"]}