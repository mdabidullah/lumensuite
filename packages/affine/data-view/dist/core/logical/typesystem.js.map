{"version":3,"file":"typesystem.js","sourceRoot":"","sources":["../../../src/core/logical/typesystem.ts"],"names":[],"mappings":"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","sourcesContent":["import { LumenSuiteError, ErrorCode } from '@lumensuite/global/exceptions';\n\nexport interface TUnion {\n  type: 'union';\n  title: 'union';\n  list: TType[];\n}\n\nexport const tUnion = (list: TType[]): TUnion => ({\n  type: 'union',\n  title: 'union',\n  list,\n});\n\n// TODO treat as data type\nexport interface TArray<_Ele extends TType = TType> {\n  type: 'array';\n  ele: TType;\n  title: 'array';\n}\n\nexport const tArray = <const T extends TType>(ele: T): TArray<T> => {\n  return {\n    type: 'array',\n    title: 'array',\n    ele,\n  };\n};\nexport const isTArray = (type: TType): type is TArray => {\n  return type.type === 'array';\n};\nexport type TTypeVar = {\n  type: 'typeVar';\n  title: 'typeVar';\n  name: string;\n  bound: TType;\n};\nexport const tTypeVar = (name: string, bound: TType): TTypeVar => {\n  return {\n    type: 'typeVar',\n    title: 'typeVar',\n    name,\n    bound,\n  };\n};\nexport type TTypeRef = {\n  type: 'typeRef';\n  title: 'typeRef';\n  name: string;\n};\nexport const tTypeRef = (name: string): TTypeRef => {\n  return {\n    type: 'typeRef',\n    title: 'typeRef',\n    name,\n  };\n};\n\nexport type TFunction = {\n  type: 'function';\n  title: 'function';\n  typeVars: TTypeVar[];\n  args: TType[];\n  rt: TType;\n};\n\nexport const tFunction = (fn: {\n  typeVars?: TTypeVar[];\n  args: TType[];\n  rt: TType;\n}): TFunction => {\n  return {\n    type: 'function',\n    title: 'function',\n    typeVars: fn.typeVars ?? [],\n    args: fn.args,\n    rt: fn.rt,\n  };\n};\n\nexport type TType = TDataType | TArray | TUnion | TTypeRef | TFunction;\n\nexport type DataTypeShape = Record<string, unknown>;\nexport type TDataType<Data extends DataTypeShape = Record<string, unknown>> = {\n  type: 'data';\n  name: string;\n  data?: Data;\n};\nexport type ValueOfData<T extends DataDefine> =\n  T extends DataDefine<infer R> ? R : never;\nexport type TypeOfData<T extends DataDefine> =\n  T extends DataDefine<infer R> ? TDataType<R> : never;\n\nexport class DataDefine<Data extends DataTypeShape = Record<string, unknown>> {\n  constructor(\n    private config: DataDefineConfig<Data>,\n    private dataMap: Map<string, DataDefine>\n  ) {}\n\n  private isByName(name: string): boolean {\n    return name === this.config.name;\n  }\n\n  private isSubOfByName(superType: string): boolean {\n    if (this.isByName(superType)) {\n      return true;\n    }\n    return this.config.supers.some(sup => sup.isSubOfByName(superType));\n  }\n\n  create(data?: Data): TDataType<Data> {\n    return {\n      type: 'data',\n      name: this.config.name,\n      data,\n    };\n  }\n\n  is(data: TType): data is TDataType<Data> {\n    if (data.type !== 'data') {\n      return false;\n    }\n    return data.name === this.config.name;\n  }\n\n  isSubOf(superType: TDataType): boolean {\n    if (this.is(superType)) {\n      return true;\n    }\n    return this.config.supers.some(sup => sup.isSubOf(superType));\n  }\n\n  isSuperOf(subType: TDataType): boolean {\n    const dataDefine = this.dataMap.get(subType.name);\n    if (!dataDefine) {\n      throw new LumenSuiteError(\n        ErrorCode.DatabaseBlockError,\n        'data config not found'\n      );\n    }\n    return dataDefine.isSubOfByName(this.config.name);\n  }\n}\n\n// type DataTypeVar = {};\n\n// TODO support generic data type\ninterface DataDefineConfig<_T extends DataTypeShape> {\n  name: string;\n  supers: DataDefine[];\n}\n\ninterface DataHelper<T extends DataTypeShape> {\n  create<V = Record<string, unknown>>(name: string): DataDefineConfig<T & V>;\n\n  extends<V extends DataTypeShape>(\n    dataDefine: DataDefine<V>\n  ): DataHelper<T & V>;\n}\n\nconst createDataHelper = <T extends DataTypeShape = Record<string, unknown>>(\n  ...supers: DataDefine[]\n): DataHelper<T> => {\n  return {\n    create(name: string) {\n      return {\n        name,\n        supers,\n      };\n    },\n    extends(dataDefine) {\n      return createDataHelper(...supers, dataDefine);\n    },\n  };\n};\nconst DataHelper = createDataHelper();\n\nexport class Typesystem {\n  dataMap = new Map<string, DataDefine>();\n\n  defineData<MetaData extends DataTypeShape>(\n    config: DataDefineConfig<MetaData>\n  ): DataDefine<MetaData> {\n    const result = new DataDefine(config, this.dataMap);\n    this.dataMap.set(config.name, result);\n    return result;\n  }\n\n  instance(\n    context: Record<string, TType>,\n    realArgs: TType[],\n    realRt: TType,\n    template: TFunction\n  ): TFunction {\n    const ctx = { ...context };\n    template.args.forEach((arg, i) => {\n      const realArg = realArgs[i];\n      if (realArg) {\n        this.isSubtype(arg, realArg, ctx);\n      }\n    });\n    this.isSubtype(realRt, template.rt);\n    return this.subst(ctx, template);\n  }\n\n  isDataType(t: TType): t is TDataType {\n    return t.type === 'data';\n  }\n\n  isSubtype(\n    superType: TType,\n    sub: TType,\n    context?: Record<string, TType>\n  ): boolean {\n    if (superType.type === 'typeRef') {\n      // TODO both are ref\n      if (context && sub.type != 'typeRef') {\n        context[superType.name] = sub;\n      }\n      // TODO bound\n      return true;\n    }\n    if (sub.type === 'typeRef') {\n      // TODO both are ref\n      if (context) {\n        context[sub.name] = superType;\n      }\n      return true;\n    }\n    if (tUnknown.is(superType)) {\n      return true;\n    }\n    if (superType.type === 'union') {\n      return superType.list.some(type => this.isSubtype(type, sub, context));\n    }\n    if (sub.type === 'union') {\n      return sub.list.every(type => this.isSubtype(superType, type, context));\n    }\n\n    if (this.isDataType(sub)) {\n      const dataDefine = this.dataMap.get(sub.name);\n      if (!dataDefine) {\n        throw new LumenSuiteError(\n          ErrorCode.DatabaseBlockError,\n          'data config not found'\n        );\n      }\n      if (!this.isDataType(superType)) {\n        return false;\n      }\n      return dataDefine.isSubOf(superType);\n    }\n\n    if (superType.type === 'array' || sub.type === 'array') {\n      if (superType.type !== 'array' || sub.type !== 'array') {\n        return false;\n      }\n      return this.isSubtype(superType.ele, sub.ele, context);\n    }\n    return false;\n  }\n\n  subst(context: Record<string, TType>, template: TFunction): TFunction {\n    const subst = (type: TType): TType => {\n      if (this.isDataType(type)) {\n        return type;\n      }\n      switch (type.type) {\n        case 'typeRef':\n          return { ...context[type.name] };\n        case 'union':\n          return tUnion(type.list.map(type => subst(type)));\n        case 'array':\n          return tArray(subst(type.ele));\n        case 'function':\n          throw new LumenSuiteError(\n            ErrorCode.DatabaseBlockError,\n            'not implement yet'\n          );\n      }\n    };\n    const result = tFunction({\n      args: template.args.map(type => subst(type)),\n      rt: subst(template.rt),\n    });\n    return result;\n  }\n}\n\nexport const typesystem = new Typesystem();\n\nexport const tUnknown = typesystem.defineData(DataHelper.create('Unknown'));\n"]}