{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../src/elements/text/utils.ts"],"names":[],"mappings":"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","sourcesContent":["// something comes from https://github.com/excalidraw/excalidraw/blob/b1311a407a636c87ee0ca326fd20599d0ce4ba9b/src/utils.ts\n\nimport type { FontFamily } from '@blocksuite/affine-model';\n\nimport { wrapFontFamily } from '../../utils/font.js';\n\nconst RS_LTR_CHARS =\n  'A-Za-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u02B8\\u0300-\\u0590\\u0800-\\u1FFF' +\n  '\\u2C00-\\uFB1C\\uFDFE-\\uFE6F\\uFEFD-\\uFFFF';\nconst RS_RTL_CHARS = '\\u0591-\\u07FF\\uFB1D-\\uFDFD\\uFE70-\\uFEFC';\n// eslint-disable-next-line no-misleading-character-class\nconst RE_RTL_CHECK = new RegExp(`^[^${RS_LTR_CHARS}]*[${RS_RTL_CHARS}]`);\nexport const isRTL = (text: string) => RE_RTL_CHECK.test(text);\n\nconst getMeasureCtx = (function initMeasureContext() {\n  let ctx: CanvasRenderingContext2D | null = null;\n  let canvas: HTMLCanvasElement | null = null;\n\n  return () => {\n    if (!canvas) {\n      canvas = document.createElement('canvas');\n      ctx = canvas.getContext('2d')!;\n    }\n\n    return ctx!;\n  };\n})();\n\nconst cachedFontFamily = new Map<\n  string,\n  {\n    fontSize: number;\n    lineHeight: number;\n  }\n>();\nexport function getLineHeight(fontFamily: FontFamily, fontSize: number) {\n  const ctx = getMeasureCtx();\n  const wrappedFontFamily = wrapFontFamily(fontFamily);\n\n  if (cachedFontFamily.has(wrappedFontFamily)) {\n    const cache = cachedFontFamily.get(wrappedFontFamily)!;\n    return (fontSize / cache.fontSize) * cache.lineHeight;\n  }\n\n  const font = `${fontSize}px ${wrapFontFamily(fontFamily)}`;\n  ctx.font = `${fontSize}px ${wrapFontFamily(fontFamily)}`;\n  const textMetrics = ctx.measureText('M');\n  const lineHeight =\n    textMetrics.fontBoundingBoxAscent + textMetrics.fontBoundingBoxDescent;\n\n  // cached when font property does not fallback\n  if (font === ctx.font) {\n    cachedFontFamily.set(wrappedFontFamily, { fontSize, lineHeight });\n  }\n\n  return lineHeight;\n}\n\nexport function getFontString({\n  fontStyle,\n  fontWeight,\n  fontSize,\n  fontFamily,\n}: {\n  fontFamily: FontFamily;\n  fontSize: number;\n  fontStyle: string;\n  fontWeight: string;\n}): string {\n  const lineHeight = getLineHeight(fontFamily, fontSize);\n  return `${fontStyle} ${fontWeight} ${fontSize}px/${lineHeight}px ${wrapFontFamily(\n    fontFamily\n  )}, sans-serif`.trim();\n}\n\nexport function normalizeText(text: string): string {\n  return (\n    text\n      // replace tabs with spaces so they render and measure correctly\n      .replace(/\\t/g, '        ')\n      // normalize newlines\n      .replace(/\\r?\\n|\\r/g, '\\n')\n  );\n}\n\nexport function splitIntoLines(text: string): string[] {\n  return normalizeText(text).split('\\n');\n}\n\nexport function getLineWidth(text: string, font: string): number {\n  const ctx = getMeasureCtx();\n  if (font !== ctx.font) ctx.font = font;\n  const width = ctx.measureText(text).width;\n\n  return width;\n}\n\nexport function getTextRect(\n  text: string,\n  fontFamily: string,\n  fontSize: number\n): { w: number; h: number } {\n  text = text\n    .split('\\n')\n    .map(x => x || ' ')\n    .join('\\n');\n\n  const lineHeight = getLineHeight(fontFamily as FontFamily, fontSize);\n  const font = `${fontSize}px \"${fontFamily}\"`;\n  const w = getTextWidth(text, font);\n  const h = getTextHeight(text, lineHeight);\n  return { w, h };\n}\n\nexport function getTextWidth(text: string, font: string): number {\n  const lines = splitIntoLines(text);\n  let width = 0;\n  lines.forEach(line => {\n    width = Math.max(width, getLineWidth(line, font));\n  });\n  return width;\n}\n\nexport const getTextHeight = (text: string, lineHeight: number) => {\n  const lineCount = splitIntoLines(text).length;\n  return lineHeight * lineCount;\n};\n\nexport function parseTokens(text: string): string[] {\n  // Splitting words containing \"-\" as those are treated as separate words\n  // by css wrapping algorithm eg non-profit => non-, profit\n  const words = text.split('-');\n  if (words.length > 1) {\n    // non-proft org => ['non-', 'profit org']\n    words.forEach((word, index) => {\n      if (index !== words.length - 1) {\n        words[index] = word += '-';\n      }\n    });\n  }\n  // Joining the words with space and splitting them again with space to get the\n  // final list of tokens\n  // ['non-', 'profit org'] =>,'non- profit org' => ['non-','profit','org']\n  return words.join(' ').split(' ');\n}\n\nexport const charWidth = (() => {\n  const cachedCharWidth: Record<string, Array<number>> = {};\n\n  const calculate = (char: string, font: string) => {\n    const ascii = char.charCodeAt(0);\n    if (!cachedCharWidth[font]) {\n      cachedCharWidth[font] = [];\n    }\n    if (!cachedCharWidth[font][ascii]) {\n      const width = getLineWidth(char, font);\n      cachedCharWidth[font][ascii] = width;\n    }\n\n    return cachedCharWidth[font][ascii];\n  };\n\n  const getCache = (font: string) => {\n    return cachedCharWidth[font];\n  };\n  return {\n    calculate,\n    getCache,\n  };\n})();\n\nexport function wrapText(text: string, font: string, maxWidth: number): string {\n  // if maxWidth is not finite or NaN which can happen in case of bugs in\n  // computation, we need to make sure we don't continue as we'll end up\n  // in an infinite loop\n  if (!Number.isFinite(maxWidth) || maxWidth < 0) {\n    return text;\n  }\n\n  const lines: Array<string> = [];\n  const originalLines = text.split('\\n');\n  const spaceWidth = getLineWidth(' ', font);\n\n  let currentLine = '';\n  let currentLineWidthTillNow = 0;\n\n  const push = (str: string) => {\n    if (str.trim()) {\n      lines.push(str);\n    }\n  };\n\n  const resetParams = () => {\n    currentLine = '';\n    currentLineWidthTillNow = 0;\n  };\n  originalLines.forEach(originalLine => {\n    const currentLineWidth = getTextWidth(originalLine, font);\n\n    // Push the line if its <= maxWidth\n    if (currentLineWidth <= maxWidth) {\n      lines.push(originalLine);\n      return; // continue\n    }\n\n    const words = parseTokens(originalLine);\n    resetParams();\n\n    let index = 0;\n\n    while (index < words.length) {\n      const currentWordWidth = getLineWidth(words[index], font);\n\n      // This will only happen when single word takes entire width\n      if (currentWordWidth === maxWidth) {\n        push(words[index]);\n        index++;\n      }\n\n      // Start breaking longer words exceeding max width\n      else if (currentWordWidth > maxWidth) {\n        // push current line since the current word exceeds the max width\n        // so will be appended in next line\n\n        push(currentLine);\n\n        resetParams();\n\n        while (words[index].length > 0) {\n          const currentChar = String.fromCodePoint(\n            words[index].codePointAt(0)!\n          );\n          const width = charWidth.calculate(currentChar, font);\n          currentLineWidthTillNow += width;\n          words[index] = words[index].slice(currentChar.length);\n\n          if (currentLineWidthTillNow >= maxWidth) {\n            push(currentLine);\n            currentLine = currentChar;\n            currentLineWidthTillNow = width;\n          } else {\n            currentLine += currentChar;\n          }\n        }\n        // push current line if appending space exceeds max width\n        if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n          push(currentLine);\n          resetParams();\n          // space needs to be appended before next word\n          // as currentLine contains chars which couldn't be appended\n          // to previous line unless the line ends with hyphen to sync\n          // with css word-wrap\n        } else if (!currentLine.endsWith('-')) {\n          currentLine += ' ';\n          currentLineWidthTillNow += spaceWidth;\n        }\n        index++;\n      } else {\n        // Start appending words in a line till max width reached\n        while (currentLineWidthTillNow < maxWidth && index < words.length) {\n          const word = words[index];\n          currentLineWidthTillNow = getLineWidth(currentLine + word, font);\n\n          if (currentLineWidthTillNow > maxWidth) {\n            push(currentLine);\n            resetParams();\n\n            break;\n          }\n          index++;\n\n          // if word ends with \"-\" then we don't need to add space\n          // to sync with css word-wrap\n          const shouldAppendSpace = !word.endsWith('-');\n          currentLine += word;\n\n          if (shouldAppendSpace) {\n            currentLine += ' ';\n          }\n\n          // Push the word if appending space exceeds max width\n          if (currentLineWidthTillNow + spaceWidth >= maxWidth) {\n            if (shouldAppendSpace) {\n              lines.push(currentLine.slice(0, -1));\n            } else {\n              lines.push(currentLine);\n            }\n            resetParams();\n            break;\n          }\n        }\n      }\n    }\n    if (currentLine.slice(-1) === ' ') {\n      // only remove last trailing space which we have added when joining words\n      currentLine = currentLine.slice(0, -1);\n      push(currentLine);\n    }\n  });\n  return lines.join('\\n');\n}\n"]}