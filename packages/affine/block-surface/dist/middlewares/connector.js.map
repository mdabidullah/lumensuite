{"version":3,"file":"connector.js","sourceRoot":"","sources":["../../src/middlewares/connector.ts"],"names":[],"mappings":"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","sourcesContent":["import type { ConnectorElementModel } from '@blocksuite/affine-model';\nimport type { GfxModel } from '@blocksuite/block-std/gfx';\n\nimport type { SurfaceBlockModel, SurfaceMiddleware } from '../surface-model.js';\n\nimport { ConnectorPathGenerator } from '../managers/connector-manager.js';\n\nexport const connectorMiddleware: SurfaceMiddleware = (\n  surface: SurfaceBlockModel\n) => {\n  const hasElementById = (id: string) =>\n    surface.hasElementById(id) || surface.doc.hasBlockById(id);\n  const elementGetter = (id: string) =>\n    surface.getElementById(id) ?? (surface.doc.getBlockById(id) as GfxModel);\n  const updateConnectorPath = (connector: ConnectorElementModel) => {\n    if (\n      ((connector.source?.id && hasElementById(connector.source.id)) ||\n        (!connector.source?.id && connector.source?.position)) &&\n      ((connector.target?.id && hasElementById(connector.target.id)) ||\n        (!connector.target?.id && connector.target?.position))\n    ) {\n      ConnectorPathGenerator.updatePath(connector, null, elementGetter);\n    }\n  };\n  const pendingList = new Set<ConnectorElementModel>();\n  let pendingFlag = false;\n  const addToUpdateList = (connector: ConnectorElementModel) => {\n    pendingList.add(connector);\n\n    if (!pendingFlag) {\n      pendingFlag = true;\n      queueMicrotask(() => {\n        pendingList.forEach(updateConnectorPath);\n        pendingList.clear();\n        pendingFlag = false;\n      });\n    }\n  };\n\n  const disposables = [\n    surface.elementAdded.on(({ id }) => {\n      const element = elementGetter(id);\n\n      if (!element) return;\n\n      if ('type' in element && element.type === 'connector') {\n        addToUpdateList(element as ConnectorElementModel);\n      } else {\n        surface.getConnectors(id).forEach(addToUpdateList);\n      }\n    }),\n    surface.elementUpdated.on(({ id, props }) => {\n      const element = elementGetter(id);\n\n      if (props['xywh'] || props['rotate']) {\n        surface.getConnectors(id).forEach(addToUpdateList);\n      }\n\n      if (\n        'type' in element &&\n        element.type === 'connector' &&\n        (props['mode'] !== undefined ||\n          props['target'] ||\n          props['source'] ||\n          (props['xywh'] && !(element as ConnectorElementModel).updatingPath))\n      ) {\n        addToUpdateList(element as ConnectorElementModel);\n      }\n    }),\n    surface.doc.slots.blockUpdated.on(payload => {\n      if (\n        payload.type === 'add' ||\n        (payload.type === 'update' && payload.props.key === 'xywh')\n      ) {\n        surface.getConnectors(payload.id).forEach(addToUpdateList);\n      }\n    }),\n  ];\n\n  surface\n    .getElementsByType('connector')\n    .forEach(connector =>\n      updateConnectorPath(connector as ConnectorElementModel)\n    );\n\n  return () => {\n    disposables.forEach(d => d.dispose());\n  };\n};\n"]}