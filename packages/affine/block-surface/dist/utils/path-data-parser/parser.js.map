{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../../src/utils/path-data-parser/parser.ts"],"names":[],"mappings":"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","sourcesContent":["const COMMAND = 0;\nconst NUMBER = 1;\nconst EOD = 2;\ntype TokenType = 0 | 1 | 2;\n\ninterface PathToken {\n  type: TokenType;\n  text: string;\n}\n\nexport interface Segment {\n  key: string;\n  data: number[];\n}\n\nconst PARAMS: Record<string, number> = {\n  A: 7,\n  a: 7,\n  C: 6,\n  c: 6,\n  H: 1,\n  h: 1,\n  L: 2,\n  l: 2,\n  M: 2,\n  m: 2,\n  Q: 4,\n  q: 4,\n  S: 4,\n  s: 4,\n  T: 2,\n  t: 2,\n  V: 1,\n  v: 1,\n  Z: 0,\n  z: 0,\n};\n\nfunction tokenize(d: string): PathToken[] {\n  const tokens: PathToken[] = [];\n  let match: RegExpMatchArray | null;\n\n  while (d !== '') {\n    match = d.match(/^([ \\t\\r\\n,]+)/);\n    if (match) {\n      d = d.slice(match[0].length);\n      continue;\n    }\n    match = d.match(/^([aAcChHlLmMqQsStTvVzZ])/);\n    if (match) {\n      tokens.push({ type: COMMAND, text: match[0] });\n      d = d.slice(match[0].length);\n      continue;\n    }\n    match = d.match(\n      /^(([-+]?[0-9]+(\\.[0-9]*)?|[-+]?\\.[0-9]+)([eE][-+]?[0-9]+)?)/\n    );\n    if (match) {\n      tokens.push({ type: NUMBER, text: `${parseFloat(match[0])}` });\n      d = d.slice(match[0].length);\n    } else {\n      return [];\n    }\n  }\n  tokens.push({ type: EOD, text: '' });\n  return tokens;\n}\n\nfunction isType(token: PathToken, type: number) {\n  return token.type === type;\n}\n\nexport function parsePath(d: string): Segment[] {\n  const segments: Segment[] = [];\n  const tokens = tokenize(d);\n  let mode = 'BOD';\n  let index = 0;\n  let token = tokens[index];\n  while (!isType(token, EOD)) {\n    let paramsCount = 0;\n    const params: number[] = [];\n    if (mode === 'BOD') {\n      if (token.text === 'M' || token.text === 'm') {\n        index++;\n        paramsCount = PARAMS[token.text];\n        mode = token.text;\n      } else {\n        return parsePath('M0,0' + d);\n      }\n    } else if (isType(token, NUMBER)) {\n      paramsCount = PARAMS[mode];\n    } else {\n      index++;\n      paramsCount = PARAMS[token.text];\n      mode = token.text;\n    }\n    if (index + paramsCount < tokens.length) {\n      for (let i = index; i < index + paramsCount; i++) {\n        const numbeToken = tokens[i];\n        if (isType(numbeToken, NUMBER)) {\n          params[params.length] = +numbeToken.text;\n        } else {\n          throw new Error(\n            'Param not a number: ' + mode + ',' + numbeToken.text\n          );\n        }\n      }\n      if (typeof PARAMS[mode] === 'number') {\n        const segment: Segment = { key: mode, data: params };\n        segments.push(segment);\n        index += paramsCount;\n        token = tokens[index];\n        if (mode === 'M') mode = 'L';\n        if (mode === 'm') mode = 'l';\n      } else {\n        throw new Error('Bad segment: ' + mode);\n      }\n    } else {\n      throw new Error('Path data ended short');\n    }\n  }\n  return segments;\n}\n\nexport function serialize(segments: Segment[]): string {\n  const tokens: (string | number)[] = [];\n  for (const { key, data } of segments) {\n    tokens.push(key);\n    switch (key) {\n      case 'C':\n      case 'c':\n        tokens.push(\n          data[0],\n          `${data[1]},`,\n          data[2],\n          `${data[3]},`,\n          data[4],\n          data[5]\n        );\n        break;\n      case 'S':\n      case 's':\n      case 'Q':\n      case 'q':\n        tokens.push(data[0], `${data[1]},`, data[2], data[3]);\n        break;\n      default:\n        tokens.push(...data);\n        break;\n    }\n  }\n  return tokens.join(' ');\n}\n"]}