{"version":3,"file":"layer-utils.js","sourceRoot":"","sources":["../../src/managers/layer-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { GfxModel } from '@lumensuite/block-std/gfx';\nimport type { Doc } from '@lumensuite/store';\n\nimport { nToLast } from '@lumensuite/global/utils';\n\nimport type { SurfaceBlockModel } from '../surface-model.js';\nimport type { Layer } from './layer-manager.js';\n\nimport { SurfaceGroupLikeModel } from '../element-model/base.js';\n\nexport function getLayerEndZIndex(layers: Layer[], layerIndex: number) {\n  const layer = layers[layerIndex];\n  return layer\n    ? layer.type === 'block'\n      ? layer.zIndex + layer.elements.length - 1\n      : layer.zIndex\n    : 1;\n}\n\nexport function updateLayersZIndex(layers: Layer[], startIdx: number) {\n  const startLayer = layers[startIdx];\n  let curIndex = startLayer.zIndex;\n\n  for (let i = startIdx; i < layers.length; ++i) {\n    const curLayer = layers[i];\n\n    curLayer.zIndex = curIndex;\n    curIndex += curLayer.type === 'block' ? curLayer.elements.length : 1;\n  }\n}\n\nexport function getElementIndex(indexable: GfxModel) {\n  const groups = indexable.groups as LumenSuite.SurfaceGroupLikeModel[];\n\n  if (groups.length) {\n    const groupIndexes = groups\n      .map(group => group.index)\n      .reverse()\n      .join('-');\n\n    return `${groupIndexes}-${indexable.index}`;\n  }\n\n  return indexable.index;\n}\n\nexport function ungroupIndex(index: string) {\n  return index.split('-')[0];\n}\n\nexport function insertToOrderedArray(array: GfxModel[], element: GfxModel) {\n  let idx = 0;\n  while (\n    idx < array.length &&\n    [SortOrder.BEFORE, SortOrder.SAME].includes(compare(array[idx], element))\n  ) {\n    ++idx;\n  }\n\n  array.splice(idx, 0, element);\n}\n\nexport function removeFromOrderedArray(array: GfxModel[], element: GfxModel) {\n  const idx = array.indexOf(element);\n\n  if (idx !== -1) {\n    array.splice(idx, 1);\n  }\n}\n\nexport enum SortOrder {\n  AFTER = 1,\n  BEFORE = -1,\n  SAME = 0,\n}\n\nexport function isInRange(edges: [GfxModel, GfxModel], target: GfxModel) {\n  return compare(target, edges[0]) >= 0 && compare(target, edges[1]) < 0;\n}\n\nexport function renderableInEdgeless(\n  doc: Doc,\n  surface: SurfaceBlockModel,\n  block: LumenSuite.EdgelessBlockModelType\n) {\n  const parent = doc.getParent(block);\n\n  return parent === doc.root || parent === surface;\n}\n\n/**\n * A comparator function for sorting elements in the surface.\n * SortOrder.AFTER means a should be rendered after b and so on.\n * @returns\n */\nexport function compare(a: GfxModel, b: GfxModel) {\n  if (a instanceof SurfaceGroupLikeModel && a.hasDescendant(b)) {\n    return SortOrder.BEFORE;\n  } else if (b instanceof SurfaceGroupLikeModel && b.hasDescendant(a)) {\n    return SortOrder.AFTER;\n  } else {\n    const aGroups = a.groups as LumenSuite.SurfaceGroupLikeModel[];\n    const bGroups = b.groups as LumenSuite.SurfaceGroupLikeModel[];\n\n    let i = 1;\n    let aGroup: GfxModel | undefined = nToLast(aGroups, i);\n    let bGroup: GfxModel | undefined = nToLast(bGroups, i);\n\n    while (aGroup === bGroup && aGroup) {\n      ++i;\n      aGroup = nToLast(aGroups, i);\n      bGroup = nToLast(bGroups, i);\n    }\n\n    aGroup = aGroup ?? a;\n    bGroup = bGroup ?? b;\n\n    return aGroup.index === bGroup.index\n      ? SortOrder.SAME\n      : aGroup.index < bGroup.index\n        ? SortOrder.BEFORE\n        : SortOrder.AFTER;\n  }\n}\n"]}