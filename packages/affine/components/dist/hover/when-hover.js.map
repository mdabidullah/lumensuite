{"version":3,"file":"when-hover.js","sourceRoot":"","sources":["../../src/hover/when-hover.ts"],"names":[],"mappings":"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","sourcesContent":["import type { HoverMiddleware, WhenHoverOptions } from './types.js';\n\nimport { dedupe, delayHide, delayShow } from './middlewares/basic.js';\nimport { safeBridge, safeTriangle } from './middlewares/safe-area.js';\n\n/**\n * Call the `whenHoverChange` callback when the element is hovered.\n *\n * After the mouse leaves the element, there is a 300ms delay by default.\n *\n * Note: The callback may be called multiple times when the mouse is hovering or hovering out.\n *\n * See also https://floating-ui.com/docs/useHover\n *\n * @example\n * ```ts\n * private _setReference: RefOrCallback;\n *\n * connectedCallback() {\n *   let hoverTip: HTMLElement | null = null;\n *   const { setReference, setFloating } = whenHover(isHover => {\n *     if (!isHover) {\n *       hoverTips?.remove();\n *       return;\n *     }\n *     hoverTip = document.createElement('div');\n *     document.body.append(hoverTip);\n *     setFloating(hoverTip);\n *   }, { hoverDelay: 500 });\n *   this._setReference = setReference;\n * }\n *\n * render() {\n *   return html`\n *     <div ref=${this._setReference}></div>\n *   `;\n * }\n * ```\n */\nexport const whenHover = (\n  whenHoverChange: (isHover: boolean, event?: Event) => void,\n  {\n    enterDelay = 0,\n    leaveDelay = 250,\n    alwayRunWhenNoFloating = true,\n    safeTriangle: triangleOptions = false,\n    safeBridge: bridgeOptions = true,\n  }: WhenHoverOptions = {}\n) => {\n  /**\n   * The event listener will be removed when the signal is aborted.\n   */\n  const abortController = new AbortController();\n  let referenceElement: Element | undefined;\n  let floatingElement: Element | undefined;\n\n  const middlewares: HoverMiddleware[] = [\n    dedupe(alwayRunWhenNoFloating),\n    triangleOptions &&\n      safeTriangle(\n        typeof triangleOptions === 'boolean' ? undefined : triangleOptions\n      ),\n    bridgeOptions &&\n      safeBridge(\n        typeof bridgeOptions === 'boolean' ? undefined : bridgeOptions\n      ),\n    delayShow(enterDelay),\n    delayHide(leaveDelay),\n  ].filter(v => typeof v !== 'boolean') as HoverMiddleware[];\n\n  let currentEvent: Event | null = null;\n  const onHoverChange = (async (e: Event) => {\n    currentEvent = e;\n    for (const middleware of middlewares) {\n      const go = await middleware({\n        event: e,\n        floatingElement,\n        referenceElement,\n      });\n      if (!go) return;\n    }\n    // ignore expired event\n    if (e !== currentEvent) return;\n    const isHover = e.type === 'mouseover' ? true : false;\n    whenHoverChange(isHover, e);\n  }) as (e: Event) => void;\n\n  const addHoverListener = (element?: Element) => {\n    if (!element) return;\n    // see https://stackoverflow.com/questions/14795099/pure-javascript-to-check-if-something-has-hover-without-setting-on-mouseover-ou\n    const alreadyHover = element.matches(':hover');\n    if (alreadyHover && !abortController.signal.aborted) {\n      // When the element is already hovered, we need to trigger the callback manually\n      onHoverChange(new MouseEvent('mouseover'));\n    }\n    element.addEventListener('mouseover', onHoverChange, {\n      capture: true,\n      signal: abortController.signal,\n    });\n    element.addEventListener('mouseleave', onHoverChange, {\n      // Please refrain use `capture: true` here.\n      // It will cause the `mouseleave` trigger incorrectly when the pointer is still within the element.\n      // The issue is detailed in https://github.com/toeverything/blocksuite/issues/6241\n      //\n      // The `mouseleave` does not **bubble**.\n      // This means that `mouseleave` is fired when the pointer has exited the element and all of its descendants,\n      // If `capture` is used, all `mouseleave` events will be received when the pointer leaves the element or leaves one of the element's descendants (even if the pointer is still within the element).\n      //\n      // capture: true,\n      signal: abortController.signal,\n    });\n  };\n\n  const removeHoverListener = (element?: Element) => {\n    if (!element) return;\n    element.removeEventListener('mouseover', onHoverChange);\n    element.removeEventListener('mouseleave', onHoverChange);\n  };\n\n  const setReference = (element?: Element) => {\n    // Clean previous listeners\n    removeHoverListener(referenceElement);\n    addHoverListener(element);\n    referenceElement = element;\n  };\n\n  const setFloating = (element?: Element) => {\n    // Clean previous listeners\n    removeHoverListener(floatingElement);\n    addHoverListener(element);\n    floatingElement = element;\n  };\n\n  return {\n    setReference,\n    setFloating,\n    dispose: () => {\n      abortController.abort();\n    },\n  };\n};\n\nexport type { WhenHoverOptions };\n"]}