{"version":3,"file":"format-text.js","sourceRoot":"","sources":["../../../src/rich-text/format/format-text.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Command, TextSelection } from '@lumensuite/block-std';\n\nimport { INLINE_ROOT_ATTR, type InlineRootElement } from '@lumensuite/inline';\n\nimport type { AffineTextAttributes } from '../extension/index.js';\n\nimport { FORMAT_TEXT_SUPPORT_FLAVOURS } from './consts.js';\nimport { clearMarksOnDiscontinuousInput } from './utils.js';\n\n// for text selection\nexport const formatTextCommand: Command<\n  'currentTextSelection',\n  never,\n  {\n    textSelection?: TextSelection;\n    styles: AffineTextAttributes;\n    mode?: 'replace' | 'merge';\n  }\n> = (ctx, next) => {\n  const { styles, mode = 'merge' } = ctx;\n\n  const textSelection = ctx.textSelection ?? ctx.currentTextSelection;\n  if (!textSelection) return;\n\n  const success = ctx.std.command\n    .chain()\n    .getSelectedBlocks({\n      textSelection,\n      filter: el =>\n        FORMAT_TEXT_SUPPORT_FLAVOURS.includes(\n          el.model.flavour as LumenSuite.Flavour\n        ),\n      types: ['text'],\n    })\n    .inline((ctx, next) => {\n      const { selectedBlocks } = ctx;\n      if (!selectedBlocks) return;\n\n      const selectedInlineEditors = selectedBlocks.flatMap(el => {\n        const inlineRoot = el.querySelector<\n          InlineRootElement<AffineTextAttributes>\n        >(`[${INLINE_ROOT_ATTR}]`);\n        if (inlineRoot && inlineRoot.inlineEditor.getInlineRange()) {\n          return inlineRoot.inlineEditor;\n        }\n        return [];\n      });\n\n      selectedInlineEditors.forEach(inlineEditor => {\n        const inlineRange = inlineEditor.getInlineRange();\n        if (!inlineRange) return;\n\n        if (inlineRange.length === 0) {\n          const delta = inlineEditor.getDeltaByRangeIndex(inlineRange.index);\n          if (!delta) return;\n\n          inlineEditor.setMarks({\n            ...inlineEditor.marks,\n            ...Object.fromEntries(\n              Object.entries(styles).map(([key, value]) => {\n                if (typeof value === 'boolean') {\n                  return [\n                    key,\n                    (inlineEditor.marks &&\n                      inlineEditor.marks[key as keyof AffineTextAttributes]) ||\n                    (delta.attributes &&\n                      delta.attributes[key as keyof AffineTextAttributes])\n                      ? null\n                      : value,\n                  ];\n                }\n                return [key, value];\n              })\n            ),\n          });\n          clearMarksOnDiscontinuousInput(inlineEditor);\n        } else {\n          inlineEditor.formatText(inlineRange, styles, {\n            mode,\n          });\n        }\n      });\n\n      Promise.all(selectedBlocks.map(el => el.updateComplete))\n        .then(() => {\n          ctx.std.range.syncTextSelectionToRange(textSelection);\n        })\n        .catch(console.error);\n\n      next();\n    })\n    .run();\n\n  if (success) next();\n};\n\ndeclare global {\n  namespace LumenSuite {\n    interface Commands {\n      formatText: typeof formatTextCommand;\n    }\n  }\n}\n"]}