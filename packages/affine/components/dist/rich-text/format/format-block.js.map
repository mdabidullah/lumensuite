{"version":3,"file":"format-block.js","sourceRoot":"","sources":["../../../src/rich-text/format/format-block.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,YAAY,EAAE,MAAM,0BAA0B,CAAC;AACxD,OAAO,EAAE,gBAAgB,EAA0B,MAAM,oBAAoB,CAAC;AAE9E,OAAO,EAAE,6BAA6B,EAAE,MAAM,aAAa,CAAC;AAE5D,sBAAsB;AACtB,MAAM,CAAC,MAAM,kBAAkB,GAQ3B,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;IAChB,MAAM,eAAe,GAAG,GAAG,CAAC,eAAe,IAAI,GAAG,CAAC,sBAAsB,CAAC;IAC1E,YAAY,CACV,eAAe,EACf,4IAA4I,CAC7I,CAAC;IAEF,IAAI,eAAe,CAAC,MAAM,KAAK,CAAC;QAAE,OAAO;IAEzC,MAAM,MAAM,GAAG,GAAG,CAAC,MAAM,CAAC;IAC1B,MAAM,IAAI,GAAG,GAAG,CAAC,IAAI,IAAI,OAAO,CAAC;IAEjC,MAAM,OAAO,GAAG,GAAG,CAAC,GAAG,CAAC,OAAO;SAC5B,KAAK,EAAE;SACP,iBAAiB,CAAC;QACjB,eAAe;QACf,MAAM,EAAE,EAAE,CAAC,EAAE,CACX,6BAA6B,CAAC,QAAQ,CACpC,EAAE,CAAC,KAAK,CAAC,OAA6B,CACvC;QACH,KAAK,EAAE,CAAC,OAAO,CAAC;KACjB,CAAC;SACD,MAAM,CAAC,CAAC,GAAG,EAAE,IAAI,EAAE,EAAE;QACpB,MAAM,EAAE,cAAc,EAAE,GAAG,GAAG,CAAC;QAC/B,YAAY,CAAC,cAAc,CAAC,CAAC;QAE7B,MAAM,qBAAqB,GAAG,cAAc,CAAC,OAAO,CAAC,EAAE,CAAC,EAAE;YACxD,MAAM,UAAU,GAAG,EAAE,CAAC,aAAa,CAEjC,IAAI,gBAAgB,GAAG,CAAC,CAAC;YAC3B,IAAI,UAAU,EAAE,CAAC;gBACf,OAAO,UAAU,CAAC,YAAY,CAAC;YACjC,CAAC;YACD,OAAO,EAAE,CAAC;QACZ,CAAC,CAAC,CAAC;QAEH,qBAAqB,CAAC,OAAO,CAAC,YAAY,CAAC,EAAE;YAC3C,YAAY,CAAC,UAAU,CACrB;gBACE,KAAK,EAAE,CAAC;gBACR,MAAM,EAAE,YAAY,CAAC,WAAW;aACjC,EACD,MAAM,EACN;gBACE,IAAI;aACL,CACF,CAAC;QACJ,CAAC,CAAC,CAAC;QAEH,IAAI,EAAE,CAAC;IACT,CAAC,CAAC;SACD,GAAG,EAAE,CAAC;IAET,IAAI,OAAO;QAAE,IAAI,EAAE,CAAC;AACtB,CAAC,CAAC","sourcesContent":["import type { AffineTextAttributes } from '@lumensuite/affine-components/rich-text';\nimport type { BlockSelection, Command } from '@lumensuite/block-std';\n\nimport { assertExists } from '@lumensuite/global/utils';\nimport { INLINE_ROOT_ATTR, type InlineRootElement } from '@lumensuite/inline';\n\nimport { FORMAT_BLOCK_SUPPORT_FLAVOURS } from './consts.js';\n\n// for block selection\nexport const formatBlockCommand: Command<\n  'currentBlockSelections',\n  never,\n  {\n    blockSelections?: BlockSelection[];\n    styles: AffineTextAttributes;\n    mode?: 'replace' | 'merge';\n  }\n> = (ctx, next) => {\n  const blockSelections = ctx.blockSelections ?? ctx.currentBlockSelections;\n  assertExists(\n    blockSelections,\n    '`blockSelections` is required, you need to pass it in args or use `getBlockSelections` command before adding this command to the pipeline.'\n  );\n\n  if (blockSelections.length === 0) return;\n\n  const styles = ctx.styles;\n  const mode = ctx.mode ?? 'merge';\n\n  const success = ctx.std.command\n    .chain()\n    .getSelectedBlocks({\n      blockSelections,\n      filter: el =>\n        FORMAT_BLOCK_SUPPORT_FLAVOURS.includes(\n          el.model.flavour as LumenSuite.Flavour\n        ),\n      types: ['block'],\n    })\n    .inline((ctx, next) => {\n      const { selectedBlocks } = ctx;\n      assertExists(selectedBlocks);\n\n      const selectedInlineEditors = selectedBlocks.flatMap(el => {\n        const inlineRoot = el.querySelector<\n          InlineRootElement<AffineTextAttributes>\n        >(`[${INLINE_ROOT_ATTR}]`);\n        if (inlineRoot) {\n          return inlineRoot.inlineEditor;\n        }\n        return [];\n      });\n\n      selectedInlineEditors.forEach(inlineEditor => {\n        inlineEditor.formatText(\n          {\n            index: 0,\n            length: inlineEditor.yTextLength,\n          },\n          styles,\n          {\n            mode,\n          }\n        );\n      });\n\n      next();\n    })\n    .run();\n\n  if (success) next();\n};\n\ndeclare global {\n  namespace LumenSuite {\n    interface Commands {\n      formatBlock: typeof formatBlockCommand;\n    }\n  }\n}\n"]}