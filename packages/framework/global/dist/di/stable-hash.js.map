{"version":3,"file":"stable-hash.js","sourceRoot":"","sources":["../../src/di/stable-hash.ts"],"names":[],"mappings":"AAAA,uDAAuD;AACvD,qDAAqD;AAErD,0EAA0E;AAC1E,4EAA4E;AAC5E,6BAA6B;AAC7B,MAAM,KAAK,GAAG,IAAI,OAAO,EAAkB,CAAC;AAE5C,wBAAwB;AACxB,IAAI,OAAO,GAAG,CAAC,CAAC;AAEhB,8CAA8C;AAC9C,6CAA6C;AAC7C,mCAAmC;AACnC,iCAAiC;AACjC,6BAA6B;AAC7B,EAAE;AACF,+EAA+E;AAC/E,YAAY;AACZ,MAAM,UAAU,UAAU,CAAC,GAAQ;IACjC,MAAM,IAAI,GAAG,OAAO,GAAG,CAAC;IACxB,MAAM,WAAW,GAAG,GAAG,IAAI,GAAG,CAAC,WAAW,CAAC;IAC3C,MAAM,MAAM,GAAG,WAAW,KAAK,IAAI,CAAC;IAEpC,IAAI,MAAM,CAAC,GAAG,CAAC,KAAK,GAAG,IAAI,CAAC,MAAM,IAAI,WAAW,KAAK,MAAM,EAAE,CAAC;QAC7D,4EAA4E;QAC5E,sDAAsD;QACtD,IAAI,MAAM,GAAG,KAAK,CAAC,GAAG,CAAC,GAAG,CAAC,CAAC;QAC5B,IAAI,MAAM;YAAE,OAAO,MAAM,CAAC;QAC1B,4EAA4E;QAC5E,gCAAgC;QAChC,2EAA2E;QAC3E,MAAM,GAAG,EAAE,OAAO,GAAG,GAAG,CAAC;QACzB,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QACvB,IAAI,KAAU,CAAC;QAEf,IAAI,WAAW,KAAK,KAAK,EAAE,CAAC;YAC1B,SAAS;YACT,MAAM,GAAG,GAAG,CAAC;YACb,KAAK,KAAK,GAAG,CAAC,EAAE,KAAK,GAAG,GAAG,CAAC,MAAM,EAAE,KAAK,EAAE,EAAE,CAAC;gBAC5C,MAAM,IAAI,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC;YACzC,CAAC;YACD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QACzB,CAAC;aAAM,IAAI,WAAW,KAAK,MAAM,EAAE,CAAC;YAClC,qBAAqB;YACrB,MAAM,GAAG,GAAG,CAAC;YACb,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,IAAI,EAAE,CAAC;YACrC,OAAO,CAAC,KAAK,GAAG,IAAI,CAAC,GAAG,EAAY,CAAC,KAAK,SAAS,EAAE,CAAC;gBACpD,IAAI,GAAG,CAAC,KAAK,CAAC,KAAK,SAAS,EAAE,CAAC;oBAC7B,MAAM,IAAI,KAAK,GAAG,GAAG,GAAG,UAAU,CAAC,GAAG,CAAC,KAAK,CAAC,CAAC,GAAG,GAAG,CAAC;gBACvD,CAAC;YACH,CAAC;YACD,KAAK,CAAC,GAAG,CAAC,GAAG,EAAE,MAAM,CAAC,CAAC;QACzB,CAAC;QACD,OAAO,MAAM,CAAC;IAChB,CAAC;IACD,IAAI,MAAM;QAAE,OAAO,GAAG,CAAC,MAAM,EAAE,CAAC;IAChC,IAAI,IAAI,KAAK,QAAQ;QAAE,OAAO,GAAG,CAAC,QAAQ,EAAE,CAAC;IAC7C,OAAO,IAAI,KAAK,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,EAAE,GAAG,GAAG,CAAC;AAC5D,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n// copied from https://github.com/shuding/stable-hash\n\n// Use WeakMap to store the object-key mapping so the objects can still be\n// garbage collected. WeakMap uses a hashtable under the hood, so the lookup\n// complexity is almost O(1).\nconst table = new WeakMap<object, string>();\n\n// A counter of the key.\nlet counter = 0;\n\n// A stable hash implementation that supports:\n//  - Fast and ensures unique hash properties\n//  - Handles unserializable values\n//  - Handles object key ordering\n//  - Generates short results\n//\n// This is not a serialization function, and the result is not guaranteed to be\n// parsable.\nexport function stableHash(arg: any): string {\n  const type = typeof arg;\n  const constructor = arg && arg.constructor;\n  const isDate = constructor === Date;\n\n  if (Object(arg) === arg && !isDate && constructor !== RegExp) {\n    // Object/function, not null/date/regexp. Use WeakMap to store the id first.\n    // If it's already hashed, directly return the result.\n    let result = table.get(arg);\n    if (result) return result;\n    // Store the hash first for circular reference detection before entering the\n    // recursive `stableHash` calls.\n    // For other objects like set and map, we use this id directly as the hash.\n    result = ++counter + '~';\n    table.set(arg, result);\n    let index: any;\n\n    if (constructor === Array) {\n      // Array.\n      result = '@';\n      for (index = 0; index < arg.length; index++) {\n        result += stableHash(arg[index]) + ',';\n      }\n      table.set(arg, result);\n    } else if (constructor === Object) {\n      // Object, sort keys.\n      result = '#';\n      const keys = Object.keys(arg).sort();\n      while ((index = keys.pop() as string) !== undefined) {\n        if (arg[index] !== undefined) {\n          result += index + ':' + stableHash(arg[index]) + ',';\n        }\n      }\n      table.set(arg, result);\n    }\n    return result;\n  }\n  if (isDate) return arg.toJSON();\n  if (type === 'symbol') return arg.toString();\n  return type === 'string' ? JSON.stringify(arg) : '' + arg;\n}\n"]}