{"version":3,"file":"container.js","sourceRoot":"","sources":["../../src/di/container.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\nimport type { ServiceProvider } from './provider.js';\nimport type {\n  GeneralServiceIdentifier,\n  ServiceFactory,\n  ServiceIdentifier,\n  ServiceIdentifierType,\n  ServiceIdentifierValue,\n  ServiceScope,\n  ServiceVariant,\n  Type,\n  TypesToDeps,\n} from './types.js';\n\nimport { DEFAULT_SERVICE_VARIANT, ROOT_SCOPE } from './consts.js';\nimport { DuplicateServiceDefinitionError } from './error.js';\nimport { parseIdentifier } from './identifier.js';\nimport { BasicServiceProvider } from './provider.js';\nimport { stringifyScope } from './scope.js';\n\n/**\n * A container of services.\n *\n * Container basically is a tuple of `[scope, identifier, variant, factory]` with some helper methods.\n * It just stores the definitions of services. It never holds any instances of services.\n *\n * # Usage\n *\n * ```ts\n * const services = new Container();\n * class ServiceA {\n *   // ...\n * }\n * // add a service\n * services.add(ServiceA);\n *\n * class ServiceB {\n *   constructor(serviceA: ServiceA) {}\n * }\n * // add a service with dependency\n * services.add(ServiceB, [ServiceA]);\n *                         ^ dependency class/identifier, match ServiceB's constructor\n *\n * const FeatureA = createIdentifier<FeatureA>('Config');\n *\n * // add a implementation for a service identifier\n * services.addImpl(FeatureA, ServiceA);\n *\n * // override a service\n * services.override(ServiceA, NewServiceA);\n *\n * // create a service provider\n * const provider = services.provider();\n * ```\n *\n * # The data structure\n *\n * The data structure of Container is a three-layer nested Map, used to represent the tuple of\n * `[scope, identifier, variant, factory]`.\n * Such a data structure ensures that a service factory can be uniquely determined by `[scope, identifier, variant]`.\n *\n * When a service added:\n *\n * ```ts\n * services.add(ServiceClass)\n * ```\n *\n * The data structure will be:\n *\n * ```ts\n * Map {\n *  '': Map {                      // scope\n *   'ServiceClass': Map {         // identifier\n *     'default':                  // variant\n *        () => new ServiceClass() // factory\n *  }\n * }\n * ```\n *\n * # Dependency relationship\n *\n * The dependency relationships of services are not actually stored in the Container,\n * but are transformed into a factory function when the service is added.\n *\n * For example:\n *\n * ```ts\n * services.add(ServiceB, [ServiceA]);\n *\n * // is equivalent to\n * services.addFactory(ServiceB, (provider) => new ServiceB(provider.get(ServiceA)));\n * ```\n *\n * For multiple implementations of the same service identifier, can be defined as:\n *\n * ```ts\n * services.add(ServiceB, [[FeatureA]]);\n *\n * // is equivalent to\n * services.addFactory(ServiceB, (provider) => new ServiceB(provider.getAll(FeatureA)));\n * ```\n */\nexport class Container {\n  private readonly services = new Map<\n    string,\n    Map<string, Map<ServiceVariant, ServiceFactory>>\n  >();\n\n  /**\n   * @see {@link ContainerEditor.add}\n   */\n  get add() {\n    return new ContainerEditor(this).add;\n  }\n\n  /**\n   * @see {@link ContainerEditor.addImpl}\n   */\n  get addImpl() {\n    return new ContainerEditor(this).addImpl;\n  }\n\n  /**\n   * Create an empty service container.\n   *\n   * same as `new Container()`\n   */\n  static get EMPTY() {\n    return new Container();\n  }\n\n  /**\n   * @see {@link ContainerEditor.scope}\n   */\n  get override() {\n    return new ContainerEditor(this).override;\n  }\n\n  /**\n   * @see {@link ContainerEditor.scope}\n   */\n  get scope() {\n    return new ContainerEditor(this).scope;\n  }\n\n  /**\n   * The number of services in the container.\n   */\n  get size() {\n    let size = 0;\n    for (const [, identifiers] of this.services) {\n      for (const [, variants] of identifiers) {\n        size += variants.size;\n      }\n    }\n    return size;\n  }\n\n  /**\n   * @internal Use {@link addImpl} instead.\n   */\n  addFactory<T>(\n    identifier: GeneralServiceIdentifier<T>,\n    factory: ServiceFactory<T>,\n    { scope, override }: { scope?: ServiceScope; override?: boolean } = {}\n  ) {\n    // convert scope to string\n    const normalizedScope = stringifyScope(scope ?? ROOT_SCOPE);\n    const normalizedIdentifier = parseIdentifier(identifier);\n    const normalizedVariant =\n      normalizedIdentifier.variant ?? DEFAULT_SERVICE_VARIANT;\n\n    const services =\n      this.services.get(normalizedScope) ??\n      new Map<string, Map<ServiceVariant, ServiceFactory>>();\n\n    const variants =\n      services.get(normalizedIdentifier.identifierName) ??\n      new Map<ServiceVariant, ServiceFactory>();\n\n    // throw if service already exists, unless it is an override\n    if (variants.has(normalizedVariant) && !override) {\n      throw new DuplicateServiceDefinitionError(normalizedIdentifier);\n    }\n    variants.set(normalizedVariant, factory);\n    services.set(normalizedIdentifier.identifierName, variants);\n    this.services.set(normalizedScope, services);\n  }\n\n  /**\n   * @internal Use {@link addImpl} instead.\n   */\n  addValue<T>(\n    identifier: GeneralServiceIdentifier<T>,\n    value: T,\n    { scope, override }: { scope?: ServiceScope; override?: boolean } = {}\n  ) {\n    this.addFactory(\n      parseIdentifier(identifier) as ServiceIdentifier<T>,\n      () => value,\n      {\n        scope,\n        override,\n      }\n    );\n  }\n\n  /**\n   * Clone the entire service container.\n   *\n   * This method is quite cheap as it only clones the references.\n   *\n   * @returns A new service container with the same services.\n   */\n  clone(): Container {\n    const di = new Container();\n    for (const [scope, identifiers] of this.services) {\n      const s = new Map();\n      for (const [identifier, variants] of identifiers) {\n        s.set(identifier, new Map(variants));\n      }\n      di.services.set(scope, s);\n    }\n    return di;\n  }\n\n  /**\n   * @internal\n   */\n  getFactory(\n    identifier: ServiceIdentifierValue,\n    scope: ServiceScope = ROOT_SCOPE\n  ): ServiceFactory | undefined {\n    return this.services\n      .get(stringifyScope(scope))\n      ?.get(identifier.identifierName)\n      ?.get(identifier.variant ?? DEFAULT_SERVICE_VARIANT);\n  }\n\n  /**\n   * @internal\n   */\n  getFactoryAll(\n    identifier: ServiceIdentifierValue,\n    scope: ServiceScope = ROOT_SCOPE\n  ): Map<ServiceVariant, ServiceFactory> {\n    return new Map(\n      this.services.get(stringifyScope(scope))?.get(identifier.identifierName)\n    );\n  }\n\n  /**\n   * Create a service provider from the container.\n   *\n   * @example\n   * ```ts\n   * provider() // create a service provider for root scope\n   * provider(ScopeA, parentProvider) // create a service provider for scope A\n   * ```\n   *\n   * @param scope The scope of the service provider, default to the root scope.\n   * @param parent The parent service provider, it is required if the scope is not the root scope.\n   */\n  provider(\n    scope: ServiceScope = ROOT_SCOPE,\n    parent: ServiceProvider | null = null\n  ): ServiceProvider {\n    return new BasicServiceProvider(this, scope, parent);\n  }\n}\n\n/**\n * A helper class to edit a service container.\n */\nclass ContainerEditor {\n  private currentScope: ServiceScope = ROOT_SCOPE;\n\n  /**\n   * Add a service to the container.\n   *\n   * @see {@link Container}\n   *\n   * @example\n   * ```ts\n   * add(ServiceClass, [dependencies, ...])\n   * ```\n   */\n  add = <\n    T extends new (...args: any) => any,\n    const Deps extends TypesToDeps<ConstructorParameters<T>> = TypesToDeps<\n      ConstructorParameters<T>\n    >,\n  >(\n    cls: T,\n    ...[deps]: Deps extends [] ? [] : [Deps]\n  ): this => {\n    this.container.addFactory<any>(\n      cls as any,\n      dependenciesToFactory(cls, deps as any),\n      { scope: this.currentScope }\n    );\n\n    return this;\n  };\n\n  /**\n   * Add an implementation for identifier to the container.\n   *\n   * @see {@link Container}\n   *\n   * @example\n   * ```ts\n   * addImpl(ServiceIdentifier, ServiceClass, [dependencies, ...])\n   * or\n   * addImpl(ServiceIdentifier, Instance)\n   * or\n   * addImpl(ServiceIdentifier, Factory)\n   * ```\n   */\n  addImpl = <\n    Arg1 extends ServiceIdentifier<any>,\n    Arg2 extends Type<Trait> | ServiceFactory<Trait> | Trait,\n    Trait = ServiceIdentifierType<Arg1>,\n    Deps extends Arg2 extends Type<Trait>\n      ? TypesToDeps<ConstructorParameters<Arg2>>\n      : [] = Arg2 extends Type<Trait>\n      ? TypesToDeps<ConstructorParameters<Arg2>>\n      : [],\n    Arg3 extends Deps = Deps,\n  >(\n    identifier: Arg1,\n    arg2: Arg2,\n    ...[arg3]: Arg3 extends [] ? [] : [Arg3]\n  ): this => {\n    if (arg2 instanceof Function) {\n      this.container.addFactory<any>(\n        identifier,\n        dependenciesToFactory(arg2, arg3 as any[]),\n        { scope: this.currentScope }\n      );\n    } else {\n      this.container.addValue(identifier, arg2 as any, {\n        scope: this.currentScope,\n      });\n    }\n\n    return this;\n  };\n\n  /**\n   * same as {@link addImpl} but this method will override the service if it exists.\n   *\n   * @see {@link Container}\n   *\n   * @example\n   * ```ts\n   * override(OriginServiceClass, NewServiceClass, [dependencies, ...])\n   * or\n   * override(ServiceIdentifier, ServiceClass, [dependencies, ...])\n   * or\n   * override(ServiceIdentifier, Instance)\n   * or\n   * override(ServiceIdentifier, Factory)\n   * ```\n   */\n  override = <\n    Arg1 extends ServiceIdentifier<any>,\n    Arg2 extends Type<Trait> | ServiceFactory<Trait> | Trait,\n    Trait = ServiceIdentifierType<Arg1>,\n    Deps extends Arg2 extends Type<Trait>\n      ? TypesToDeps<ConstructorParameters<Arg2>>\n      : [] = Arg2 extends Type<Trait>\n      ? TypesToDeps<ConstructorParameters<Arg2>>\n      : [],\n    Arg3 extends Deps = Deps,\n  >(\n    identifier: Arg1,\n    arg2: Arg2,\n    ...[arg3]: Arg3 extends [] ? [] : [Arg3]\n  ): this => {\n    if (arg2 instanceof Function) {\n      this.container.addFactory<any>(\n        identifier,\n        dependenciesToFactory(arg2, arg3 as any[]),\n        { scope: this.currentScope, override: true }\n      );\n    } else {\n      this.container.addValue(identifier, arg2 as any, {\n        scope: this.currentScope,\n        override: true,\n      });\n    }\n\n    return this;\n  };\n\n  /**\n   * Set the scope for the service registered subsequently\n   *\n   * @example\n   *\n   * ```ts\n   * const ScopeA = createScope('a');\n   *\n   * services.scope(ScopeA).add(XXXService, ...);\n   * ```\n   */\n  scope = (scope: ServiceScope): ContainerEditor => {\n    this.currentScope = scope;\n    return this;\n  };\n\n  constructor(private readonly container: Container) {}\n}\n\n/**\n * Convert dependencies definition to a factory function.\n */\nfunction dependenciesToFactory(\n  cls: any,\n  deps: any[] = []\n): ServiceFactory<any> {\n  return (provider: ServiceProvider) => {\n    const args = [];\n    for (const dep of deps) {\n      let isAll;\n      let identifier;\n      if (Array.isArray(dep)) {\n        if (dep.length !== 1) {\n          throw new Error('Invalid dependency');\n        }\n        isAll = true;\n        identifier = dep[0];\n      } else {\n        isAll = false;\n        identifier = dep;\n      }\n      if (isAll) {\n        args.push(Array.from(provider.getAll(identifier).values()));\n      } else {\n        args.push(provider.get(identifier));\n      }\n    }\n    if (isConstructor(cls)) {\n      return new cls(...args, provider);\n    } else {\n      return cls(...args, provider);\n    }\n  };\n}\n\n// a hack to check if a function is a constructor\n// https://github.com/zloirock/core-js/blob/232c8462c26c75864b4397b7f643a4f57c6981d5/packages/core-js/internals/is-constructor.js#L15\nfunction isConstructor(cls: unknown) {\n  try {\n    Reflect.construct(function () {}, [], cls as never);\n    return true;\n  } catch {\n    return false;\n  }\n}\n"]}