{"version":3,"file":"identifier.js","sourceRoot":"","sources":["../../src/di/identifier.ts"],"names":[],"mappings":"AAAA,uDAAuD;AASvD,OAAO,EAAE,uBAAuB,EAAE,MAAM,aAAa,CAAC;AACtD,OAAO,EAAE,UAAU,EAAE,MAAM,kBAAkB,CAAC;AAE9C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAmEG;AACH,MAAM,UAAU,gBAAgB,CAC9B,IAAY,EACZ,UAA0B,uBAAuB;IAEjD,OAAO,MAAM,CAAC,MAAM,CAClB,CAAC,OAAuB,EAAE,EAAE;QAC1B,OAAO,gBAAgB,CAAI,IAAI,EAAE,OAAO,CAAC,CAAC;IAC5C,CAAC,EACD;QACE,cAAc,EAAE,IAAI;QACpB,OAAO;KACR,CACO,CAAC;AACb,CAAC;AAED;;;;;GAKG;AACH,MAAM,UAAU,+BAA+B,CAC7C,MAAe;IAEf,OAAO,gBAAgB,CAAI,GAAG,MAAM,CAAC,IAAI,GAAG,UAAU,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AACpE,CAAC;AAED,MAAM,UAAU,eAAe,CAAC,KAAU;IACxC,IAAI,KAAK,CAAC,cAAc,EAAE,CAAC;QACzB,OAAO,KAA+B,CAAC;IACzC,CAAC;SAAM,IAAI,OAAO,KAAK,KAAK,UAAU,IAAI,KAAK,CAAC,IAAI,EAAE,CAAC;QACrD,OAAO,+BAA+B,CAAC,KAAK,CAAC,CAAC;IAChD,CAAC;SAAM,CAAC;QACN,MAAM,IAAI,KAAK,CAAC,oCAAoC,CAAC,CAAC;IACxD,CAAC;AACH,CAAC","sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport type {\n  ServiceIdentifier,\n  ServiceIdentifierValue,\n  ServiceVariant,\n  Type,\n} from './types.js';\n\nimport { DEFAULT_SERVICE_VARIANT } from './consts.js';\nimport { stableHash } from './stable-hash.js';\n\n/**\n * create a ServiceIdentifier.\n *\n * ServiceIdentifier is used to identify a certain type of service. With the identifier, you can reference one or more services\n * without knowing the specific implementation, thereby achieving\n * [inversion of control](https://en.wikipedia.org/wiki/Inversion_of_control).\n *\n * @example\n * ```ts\n * // define a interface\n * interface Storage {\n *   get(key: string): string | null;\n *   set(key: string, value: string): void;\n * }\n *\n * // create a identifier\n * // NOTICE: Highly recommend to use the interface name as the identifier name,\n * // so that it is easy to understand. and it is legal to do so in TypeScript.\n * const Storage = createIdentifier<Storage>('Storage');\n *\n * // create a implementation\n * class LocalStorage implements Storage {\n *   get(key: string): string | null {\n *     return localStorage.getItem(key);\n *   }\n *   set(key: string, value: string): void {\n *     localStorage.setItem(key, value);\n *   }\n * }\n *\n * // register the implementation to the identifier\n * services.addImpl(Storage, LocalStorage);\n *\n * // get the implementation from the identifier\n * const storage = services.provider().get(Storage);\n * storage.set('foo', 'bar');\n * ```\n *\n * With identifier:\n *\n * * You can easily replace the implementation of a `Storage` without changing the code that uses it.\n * * You can easily mock a `Storage` for testing.\n *\n * # Variant\n *\n * Sometimes, you may want to register multiple implementations for the same interface.\n * For example, you may want have both `LocalStorage` and `SessionStorage` for `Storage`,\n * and use them in same time.\n *\n * In this case, you can use `variant` to distinguish them.\n *\n * ```ts\n * const Storage = createIdentifier<Storage>('Storage');\n * const LocalStorage = Storage('local');\n * const SessionStorage = Storage('session');\n *\n * services.addImpl(LocalStorage, LocalStorageImpl);\n * services.addImpl(SessionStorage, SessionStorageImpl);\n *\n * // get the implementation from the identifier\n * const localStorage = services.provider().get(LocalStorage);\n * const sessionStorage = services.provider().get(SessionStorage);\n * const storage = services.provider().getAll(Storage); // { local: LocalStorageImpl, session: SessionStorageImpl }\n * ```\n *\n * @param name unique name of the identifier.\n * @param variant The default variant name of the identifier, can be overridden by `identifier(\"variant\")`.\n */\nexport function createIdentifier<T>(\n  name: string,\n  variant: ServiceVariant = DEFAULT_SERVICE_VARIANT\n): ServiceIdentifier<T> & ((variant: ServiceVariant) => ServiceIdentifier<T>) {\n  return Object.assign(\n    (variant: ServiceVariant) => {\n      return createIdentifier<T>(name, variant);\n    },\n    {\n      identifierName: name,\n      variant,\n    }\n  ) as never;\n}\n\n/**\n * Convert the constructor into a ServiceIdentifier.\n * As we always deal with ServiceIdentifier in the DI container.\n *\n * @internal\n */\nexport function createIdentifierFromConstructor<T>(\n  target: Type<T>\n): ServiceIdentifier<T> {\n  return createIdentifier<T>(`${target.name}${stableHash(target)}`);\n}\n\nexport function parseIdentifier(input: any): ServiceIdentifierValue {\n  if (input.identifierName) {\n    return input as ServiceIdentifierValue;\n  } else if (typeof input === 'function' && input.name) {\n    return createIdentifierFromConstructor(input);\n  } else {\n    throw new Error('Input is not a service identifier.');\n  }\n}\n"]}