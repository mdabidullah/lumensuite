{"version":3,"file":"draw.js","sourceRoot":"","sources":["../../../src/utils/figma-squircle/draw.ts"],"names":[],"mappings":"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","sourcesContent":["interface CornerPathParams {\n  a: number;\n  b: number;\n  c: number;\n  d: number;\n  p: number;\n  cornerRadius: number;\n  arcSectionLength: number;\n}\n\ninterface CornerParams {\n  cornerRadius: number;\n  cornerSmoothing: number;\n  preserveSmoothing: boolean;\n  roundingAndSmoothingBudget: number;\n}\n\n// The article from figma's blog\n// https://www.figma.com/blog/desperately-seeking-squircles/\n//\n// The original code by MartinRGB\n// https://github.com/MartinRGB/Figma_Squircles_Approximation/blob/bf29714aab58c54329f3ca130ffa16d39a2ff08c/js/rounded-corners.js#L64\nexport function getPathParamsForCorner({\n  cornerRadius,\n  cornerSmoothing,\n  preserveSmoothing,\n  roundingAndSmoothingBudget,\n}: CornerParams): CornerPathParams {\n  // From figure 12.2 in the article\n  // p = (1 + cornerSmoothing) * q\n  // in this case q = R because theta = 90deg\n  let p = (1 + cornerSmoothing) * cornerRadius;\n\n  // When there's not enough space left (p > roundingAndSmoothingBudget), there are 2 options:\n  //\n  // 1. What figma's currently doing: limit the smoothing value to make sure p <= roundingAndSmoothingBudget\n  // But what this means is that at some point when cornerRadius is large enough,\n  // increasing the smoothing value wouldn't do anything\n  //\n  // 2. Keep the original smoothing value and use it to calculate the bezier curve normally,\n  // then adjust the control points to achieve similar curvature profile\n  //\n  // preserveSmoothing is a new option I added\n  //\n  // If preserveSmoothing is on then we'll just keep using the original smoothing value\n  // and adjust the bezier curve later\n  if (!preserveSmoothing) {\n    const maxCornerSmoothing = roundingAndSmoothingBudget / cornerRadius - 1;\n    cornerSmoothing = Math.min(cornerSmoothing, maxCornerSmoothing);\n    p = Math.min(p, roundingAndSmoothingBudget);\n  }\n\n  // In a normal rounded rectangle (cornerSmoothing = 0), this is 90\n  // The larger the smoothing, the smaller the arc\n  const arcMeasure = 90 * (1 - cornerSmoothing);\n  const arcSectionLength =\n    Math.sin(toRadians(arcMeasure / 2)) * cornerRadius * Math.sqrt(2);\n\n  // In the article this is the distance between 2 control points: P3 and P4\n  const angleAlpha = (90 - arcMeasure) / 2;\n  const p3ToP4Distance = cornerRadius * Math.tan(toRadians(angleAlpha / 2));\n\n  // a, b, c and d are from figure 11.1 in the article\n  const angleBeta = 45 * cornerSmoothing;\n  const c = p3ToP4Distance * Math.cos(toRadians(angleBeta));\n  const d = c * Math.tan(toRadians(angleBeta));\n\n  let b = (p - arcSectionLength - c - d) / 3;\n  let a = 2 * b;\n\n  // Adjust the P1 and P2 control points if there's not enough space left\n  if (preserveSmoothing && p > roundingAndSmoothingBudget) {\n    const p1ToP3MaxDistance =\n      roundingAndSmoothingBudget - d - arcSectionLength - c;\n\n    // Try to maintain some distance between P1 and P2 so the curve wouldn't look weird\n    const minA = p1ToP3MaxDistance / 6;\n    const maxB = p1ToP3MaxDistance - minA;\n\n    b = Math.min(b, maxB);\n    a = p1ToP3MaxDistance - b;\n    p = Math.min(p, roundingAndSmoothingBudget);\n  }\n\n  return {\n    a,\n    b,\n    c,\n    d,\n    p,\n    arcSectionLength,\n    cornerRadius,\n  };\n}\n\ninterface SVGPathInput {\n  width: number;\n  height: number;\n  topRightPathParams: CornerPathParams;\n  bottomRightPathParams: CornerPathParams;\n  bottomLeftPathParams: CornerPathParams;\n  topLeftPathParams: CornerPathParams;\n}\n\nexport function getSVGPathFromPathParams({\n  width,\n  height,\n  topLeftPathParams,\n  topRightPathParams,\n  bottomLeftPathParams,\n  bottomRightPathParams,\n}: SVGPathInput) {\n  return `\n    M ${width - topRightPathParams.p} 0\n    ${drawTopRightPath(topRightPathParams)}\n    L ${width} ${height - bottomRightPathParams.p}\n    ${drawBottomRightPath(bottomRightPathParams)}\n    L ${bottomLeftPathParams.p} ${height}\n    ${drawBottomLeftPath(bottomLeftPathParams)}\n    L 0 ${topLeftPathParams.p}\n    ${drawTopLeftPath(topLeftPathParams)}\n    Z\n  `\n    .replace(/[\\t\\s\\n]+/g, ' ')\n    .trim();\n}\n\nfunction drawTopRightPath({\n  cornerRadius,\n  a,\n  b,\n  c,\n  d,\n  p,\n  arcSectionLength,\n}: CornerPathParams) {\n  if (cornerRadius) {\n    return rounded`\n    c ${a} 0 ${a + b} 0 ${a + b + c} ${d}\n    a ${cornerRadius} ${cornerRadius} 0 0 1 ${arcSectionLength} ${arcSectionLength}\n    c ${d} ${c}\n        ${d} ${b + c}\n        ${d} ${a + b + c}`;\n  } else {\n    return rounded`l ${p} 0`;\n  }\n}\n\nfunction drawBottomRightPath({\n  cornerRadius,\n  a,\n  b,\n  c,\n  d,\n  p,\n  arcSectionLength,\n}: CornerPathParams) {\n  if (cornerRadius) {\n    return rounded`\n    c 0 ${a}\n      0 ${a + b}\n      ${-d} ${a + b + c}\n    a ${cornerRadius} ${cornerRadius} 0 0 1 -${arcSectionLength} ${arcSectionLength}\n    c ${-c} ${d}\n      ${-(b + c)} ${d}\n      ${-(a + b + c)} ${d}`;\n  } else {\n    return rounded`l 0 ${p}`;\n  }\n}\n\nfunction drawBottomLeftPath({\n  cornerRadius,\n  a,\n  b,\n  c,\n  d,\n  p,\n  arcSectionLength,\n}: CornerPathParams) {\n  if (cornerRadius) {\n    return rounded`\n    c ${-a} 0\n      ${-(a + b)} 0\n      ${-(a + b + c)} ${-d}\n    a ${cornerRadius} ${cornerRadius} 0 0 1 -${arcSectionLength} -${arcSectionLength}\n    c ${-d} ${-c}\n      ${-d} ${-(b + c)}\n      ${-d} ${-(a + b + c)}`;\n  } else {\n    return rounded`l ${-p} 0`;\n  }\n}\n\nfunction drawTopLeftPath({\n  cornerRadius,\n  a,\n  b,\n  c,\n  d,\n  p,\n  arcSectionLength,\n}: CornerPathParams) {\n  if (cornerRadius) {\n    return rounded`\n    c 0 ${-a}\n      0 ${-(a + b)}\n      ${d} ${-(a + b + c)}\n    a ${cornerRadius} ${cornerRadius} 0 0 1 ${arcSectionLength} -${arcSectionLength}\n    c ${c} ${-d}\n      ${b + c} ${-d}\n      ${a + b + c} ${-d}`;\n  } else {\n    return rounded`l 0 ${-p}`;\n  }\n}\n\nfunction toRadians(degrees: number) {\n  return (degrees * Math.PI) / 180;\n}\n\nfunction rounded(strings: TemplateStringsArray, ...values: number[]): string {\n  return strings.reduce((acc, str, i) => {\n    const value = values[i];\n\n    if (typeof value === 'number') {\n      return acc + str + value.toFixed(4);\n    } else {\n      return acc + str + (value ?? '');\n    }\n  }, '');\n}\n"]}