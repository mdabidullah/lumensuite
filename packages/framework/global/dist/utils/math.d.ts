import type { Bound, IBound } from './model/bound.js';
import { PointLocation } from './model/point-location.js';
import { type IVec } from './model/vec.js';
export declare const EPSILON = 1e-12;
export declare const MACHINE_EPSILON = 1.12e-16;
export declare const PI2: number;
export declare const CURVETIME_EPSILON = 1e-8;
interface TLBounds {
    minX: number;
    minY: number;
    maxX: number;
    maxY: number;
    width: number;
    height: number;
    rotation?: number;
}
export declare function randomSeed(): number;
export declare function getBoundsFromPoints(points: IVec[], rotation?: number): TLBounds;
export declare function getPointsFromBoundsWithRotation(bounds: IBound, getPoints?: (bounds: IBound) => IVec[], resPadding?: [number, number]): IVec[];
export declare function getQuadBoundsWithRotation(bounds: IBound): DOMRect;
export declare function getBoundsWithRotation(bounds: IBound): IBound;
export declare function lineIntersects(sp: IVec, ep: IVec, sp2: IVec, ep2: IVec, infinite?: boolean): IVec | null;
export declare function polygonNearestPoint(points: IVec[], point: IVec): IVec;
export declare function polygonPointDistance(points: IVec[], point: IVec): number;
export declare function rotatePoints<T extends IVec>(points: T[], center: IVec, rotate: number): T[];
export declare function rotatePoint(point: [number, number], center: IVec, rotate: number): [number, number];
export declare function toRadian(angle: number): number;
export declare function isPointOnLineSegment(point: IVec, line: IVec[]): boolean;
export declare function polygonGetPointTangent(points: IVec[], point: IVec): IVec;
export declare function linePolygonIntersects(sp: IVec, ep: IVec, points: IVec[]): PointLocation[] | null;
export declare function linePolylineIntersects(sp: IVec, ep: IVec, points: IVec[]): PointLocation[] | null;
export declare function polyLineNearestPoint(points: IVec[], point: IVec): IVec;
export declare function isPointOnlines(element: Bound, points: readonly [number, number][], rotate: number, hitPoint: [number, number], threshold: number): boolean;
export declare const distance2d: (x1: number, y1: number, x2: number, y2: number) => number;
export declare function isPointIn(a: IBound, x: number, y: number): boolean;
export declare function intersects(a: IBound, b: IBound): boolean;
export declare function almostEqual(a: number, b: number, epsilon?: number): boolean;
export declare function isVecZero(v: IVec): boolean;
export declare function isZero(x: number): boolean;
export declare function pointAlmostEqual(a: IVec, b: IVec, _epsilon?: number): boolean;
export declare function clamp(n: number, min: number, max?: number): number;
export declare function pointInEllipse(A: IVec, C: IVec, rx: number, ry: number, rotation?: number): boolean;
export declare function pointInPolygon(p: IVec, points: IVec[]): boolean;
export declare function pointOnEllipse(point: IVec, rx: number, ry: number, threshold: number): boolean;
export declare function pointOnPolygonStoke(p: IVec, points: IVec[], threshold: number): boolean;
export declare function getPolygonPathFromPoints(points: IVec[], closed?: boolean): string;
export declare function getSvgPathFromStroke(points: IVec[], closed?: boolean): string;
export declare function lineEllipseIntersects(A: IVec, B: IVec, C: IVec, rx: number, ry: number, rad?: number): PointLocation[] | null;
export declare function sign(number: number): 1 | -1;
export declare function getPointFromBoundsWithRotation(bounds: IBound, point: IVec): IVec;
export declare function normalizeDegAngle(angle: number): number;
export declare function toDegree(radian: number): number;
export declare function isOverlap(line1: IVec[], line2: IVec[], axis: 0 | 1, strict?: boolean): boolean;
export declare function getCenterAreaBounds(bounds: IBound, ratio: number): {
    x: number;
    y: number;
    w: number;
    h: number;
    rotate: number | undefined;
};
export {};
//# sourceMappingURL=math.d.ts.map