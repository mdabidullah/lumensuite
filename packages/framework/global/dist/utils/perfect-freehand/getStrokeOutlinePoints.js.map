{"version":3,"file":"getStrokeOutlinePoints.js","sourceRoot":"","sources":["../../../src/utils/perfect-freehand/getStrokeOutlinePoints.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IVec } from '@blocksuite/global/utils';\n\nimport type { StrokeOptions, StrokePoint } from './types.js';\n\nimport { getStrokeRadius } from './getStrokeRadius.js';\nimport {\n  add,\n  dist2,\n  dpr,\n  lrp,\n  mul,\n  neg,\n  per,\n  prj,\n  rotAround,\n  sub,\n  uni,\n} from './vec.js';\n\nconst { min, PI } = Math;\n\n// This is the rate of change for simulated pressure. It could be an option.\nconst RATE_OF_PRESSURE_CHANGE = 0.275;\n\n// Browser strokes seem to be off if PI is regular, a tiny offset seems to fix it\nconst FIXED_PI = PI + 0.0001;\n\n/**\n * ## getStrokeOutlinePoints\n * @description Get an array of points (as `[x, y]`) representing the outline of a stroke.\n * @param points An array of StrokePoints as returned from `getStrokePoints`.\n * @param options (optional) An object with options.\n * @param options.size\tThe base size (diameter) of the stroke.\n * @param options.thinning The effect of pressure on the stroke's size.\n * @param options.smoothing\tHow much to soften the stroke's edges.\n * @param options.easing\tAn easing function to apply to each point's pressure.\n * @param options.simulatePressure Whether to simulate pressure based on velocity.\n * @param options.start Cap, taper and easing for the start of the line.\n * @param options.end Cap, taper and easing for the end of the line.\n * @param options.last Whether to handle the points as a completed stroke.\n */\nexport function getStrokeOutlinePoints(\n  points: StrokePoint[],\n  options: Partial<StrokeOptions> = {} as Partial<StrokeOptions>\n): IVec[] {\n  const {\n    size = 16,\n    smoothing = 0.5,\n    thinning = 0.5,\n    simulatePressure = true,\n    easing = t => t,\n    start = {},\n    end = {},\n    last: isComplete = false,\n  } = options;\n\n  const { cap: capStart = true, easing: taperStartEase = t => t * (2 - t) } =\n    start;\n\n  const { cap: capEnd = true, easing: taperEndEase = t => --t * t * t + 1 } =\n    end;\n\n  // We can't do anything with an empty array or a stroke with negative size.\n  if (points.length === 0 || size <= 0) {\n    return [];\n  }\n\n  // The total length of the line\n  const totalLength = points[points.length - 1].runningLength;\n\n  const taperStart =\n    start.taper === false\n      ? 0\n      : start.taper === true\n        ? Math.max(size, totalLength)\n        : (start.taper as number);\n\n  const taperEnd =\n    end.taper === false\n      ? 0\n      : end.taper === true\n        ? Math.max(size, totalLength)\n        : (end.taper as number);\n\n  // The minimum allowed distance between points (squared)\n  const minDistance = Math.pow(size * smoothing, 2);\n\n  // Our collected left and right points\n  const leftPts: IVec[] = [];\n  const rightPts: IVec[] = [];\n\n  // Previous pressure (start with average of first five pressures,\n  // in order to prevent fat starts for every line. Drawn lines\n  // almost always start slow!\n  let prevPressure = points.slice(0, 10).reduce((acc, curr) => {\n    let pressure = curr.pressure;\n\n    if (simulatePressure) {\n      // Speed of change - how fast should the the pressure changing?\n      const sp = min(1, curr.distance / size);\n      // Rate of change - how much of a change is there?\n      const rp = min(1, 1 - sp);\n      // Accelerate the pressure\n      pressure = min(1, acc + (rp - acc) * (sp * RATE_OF_PRESSURE_CHANGE));\n    }\n\n    return (acc + pressure) / 2;\n  }, points[0].pressure);\n\n  // The current radius\n  let radius = getStrokeRadius(\n    size,\n    thinning,\n    points[points.length - 1].pressure,\n    easing\n  );\n\n  // The radius of the first saved point\n  let firstRadius: number | undefined = undefined;\n\n  // Previous vector\n  let prevVector = points[0].vector;\n\n  // Previous left and right points\n  let pl = points[0].point;\n  let pr = pl;\n\n  // Temporary left and right points\n  let tl = pl;\n  let tr = pr;\n\n  // Keep track of whether the previous point is a sharp corner\n  // ... so that we don't detect the same corner twice\n  let isPrevPointSharpCorner = false;\n\n  // let short = true\n\n  /*\n    Find the outline's left and right points\n\n    Iterating through the points and populate the rightPts and leftPts arrays,\n    skipping the first and last pointsm, which will get caps later on.\n  */\n\n  for (let i = 0; i < points.length; i++) {\n    let { pressure } = points[i];\n    const { point, vector, distance, runningLength } = points[i];\n\n    // Removes noise from the end of the line\n    if (i < points.length - 1 && totalLength - runningLength < 3) {\n      continue;\n    }\n\n    /*\n      Calculate the radius\n\n      If not thinning, the current point's radius will be half the size; or\n      otherwise, the size will be based on the current (real or simulated)\n      pressure.\n    */\n\n    if (thinning) {\n      if (simulatePressure) {\n        // If we're simulating pressure, then do so based on the distance\n        // between the current point and the previous point, and the size\n        // of the stroke. Otherwise, use the input pressure.\n        const sp = min(1, distance / size);\n        const rp = min(1, 1 - sp);\n        pressure = min(\n          1,\n          prevPressure + (rp - prevPressure) * (sp * RATE_OF_PRESSURE_CHANGE)\n        );\n      }\n\n      radius = getStrokeRadius(size, thinning, pressure, easing);\n    } else {\n      radius = size / 2;\n    }\n\n    if (firstRadius === undefined) {\n      firstRadius = radius;\n    }\n\n    /*\n      Apply tapering\n\n      If the current length is within the taper distance at either the\n      start or the end, calculate the taper strengths. Apply the smaller\n      of the two taper strengths to the radius.\n    */\n\n    const ts =\n      runningLength < taperStart\n        ? taperStartEase(runningLength / taperStart)\n        : 1;\n\n    const te =\n      totalLength - runningLength < taperEnd\n        ? taperEndEase((totalLength - runningLength) / taperEnd)\n        : 1;\n\n    radius = Math.max(0.01, radius * Math.min(ts, te));\n\n    /* Add points to left and right */\n\n    /*\n      Handle sharp corners\n\n      Find the difference (dot product) between the current and next vector.\n      If the next vector is at more than a right angle to the current vector,\n      draw a cap at the current point.\n    */\n\n    const nextVector = (i < points.length - 1 ? points[i + 1] : points[i])\n      .vector;\n    const nextDpr = i < points.length - 1 ? dpr(vector, nextVector) : 1.0;\n    const prevDpr = dpr(vector, prevVector);\n\n    const isPointSharpCorner = prevDpr < 0 && !isPrevPointSharpCorner;\n    const isNextPointSharpCorner = nextDpr !== null && nextDpr < 0;\n\n    if (isPointSharpCorner || isNextPointSharpCorner) {\n      // It's a sharp corner. Draw a rounded cap and move on to the next point\n      // Considering saving these and drawing them later? So that we can avoid\n      // crossing future points.\n\n      const offset = mul(per(prevVector), radius);\n\n      for (let step = 1 / 13, t = 0; t <= 1; t += step) {\n        tl = rotAround(sub(point, offset), point, FIXED_PI * t);\n        leftPts.push(tl);\n\n        tr = rotAround(add(point, offset), point, FIXED_PI * -t);\n        rightPts.push(tr);\n      }\n\n      pl = tl;\n      pr = tr;\n\n      if (isNextPointSharpCorner) {\n        isPrevPointSharpCorner = true;\n      }\n      continue;\n    }\n\n    isPrevPointSharpCorner = false;\n\n    // Handle the last point\n    if (i === points.length - 1) {\n      const offset = mul(per(vector), radius);\n      leftPts.push(sub(point, offset));\n      rightPts.push(add(point, offset));\n      continue;\n    }\n\n    /*\n      Add regular points\n\n      Project points to either side of the current point, using the\n      calculated size as a distance. If a point's distance to the\n      previous point on that side greater than the minimum distance\n      (or if the corner is kinda sharp), add the points to the side's\n      points array.\n    */\n\n    const offset = mul(per(lrp(nextVector, vector, nextDpr)), radius);\n\n    tl = sub(point, offset);\n\n    if (i <= 1 || dist2(pl, tl) > minDistance) {\n      leftPts.push(tl);\n      pl = tl;\n    }\n\n    tr = add(point, offset);\n\n    if (i <= 1 || dist2(pr, tr) > minDistance) {\n      rightPts.push(tr);\n      pr = tr;\n    }\n\n    // Set variables for next iteration\n    prevPressure = pressure;\n    prevVector = vector;\n  }\n\n  /*\n    Drawing caps\n\n    Now that we have our points on either side of the line, we need to\n    draw caps at the start and end. Tapered lines don't have caps, but\n    may have dots for very short lines.\n  */\n\n  const firstPoint = points[0].point.slice(0, 2) as IVec;\n\n  const lastPoint =\n    points.length > 1\n      ? (points[points.length - 1].point.slice(0, 2) as IVec)\n      : add(points[0].point, [1, 1]);\n\n  const startCap: IVec[] = [];\n\n  const endCap: IVec[] = [];\n\n  /*\n    Draw a dot for very short or completed strokes\n\n    If the line is too short to gather left or right points and if the line is\n    not tapered on either side, draw a dot. If the line is tapered, then only\n    draw a dot if the line is both very short and complete. If we draw a dot,\n    we can just return those points.\n  */\n\n  if (points.length === 1) {\n    if (!(taperStart || taperEnd) || isComplete) {\n      const start = prj(\n        firstPoint,\n        uni(per(sub(firstPoint, lastPoint))),\n        -(firstRadius || radius)\n      );\n      const dotPts: IVec[] = [];\n      for (let step = 1 / 13, t = step; t <= 1; t += step) {\n        dotPts.push(rotAround(start, firstPoint, FIXED_PI * 2 * t));\n      }\n      return dotPts;\n    }\n  } else {\n    /*\n    Draw a start cap\n\n    Unless the line has a tapered start, or unless the line has a tapered end\n    and the line is very short, draw a start cap around the first point. Use\n    the distance between the second left and right point for the cap's radius.\n    Finally remove the first left and right points. :psyduck:\n  */\n\n    if (taperStart || (taperEnd && points.length === 1)) {\n      // The start point is tapered, noop\n    } else if (capStart) {\n      // Draw the round cap - add thirteen points rotating the right point around the start point to the left point\n      for (let step = 1 / 13, t = step; t <= 1; t += step) {\n        const pt = rotAround(rightPts[0], firstPoint, FIXED_PI * t);\n        startCap.push(pt);\n      }\n    } else {\n      // Draw the flat cap - add a point to the left and right of the start point\n      const cornersVector = sub(leftPts[0], rightPts[0]);\n      const offsetA = mul(cornersVector, 0.5);\n      const offsetB = mul(cornersVector, 0.51);\n\n      startCap.push(\n        sub(firstPoint, offsetA),\n        sub(firstPoint, offsetB),\n        add(firstPoint, offsetB),\n        add(firstPoint, offsetA)\n      );\n    }\n\n    /*\n    Draw an end cap\n\n    If the line does not have a tapered end, and unless the line has a tapered\n    start and the line is very short, draw a cap around the last point. Finally,\n    remove the last left and right points. Otherwise, add the last point. Note\n    that This cap is a full-turn-and-a-half: this prevents incorrect caps on\n    sharp end turns.\n  */\n\n    const direction = per(neg(points[points.length - 1].vector));\n\n    if (taperEnd || (taperStart && points.length === 1)) {\n      // Tapered end - push the last point to the line\n      endCap.push(lastPoint);\n    } else if (capEnd) {\n      // Draw the round end cap\n      const start = prj(lastPoint, direction, radius);\n      for (let step = 1 / 29, t = step; t < 1; t += step) {\n        endCap.push(rotAround(start, lastPoint, FIXED_PI * 3 * t));\n      }\n    } else {\n      // Draw the flat end cap\n\n      endCap.push(\n        add(lastPoint, mul(direction, radius)),\n        add(lastPoint, mul(direction, radius * 0.99)),\n        sub(lastPoint, mul(direction, radius * 0.99)),\n        sub(lastPoint, mul(direction, radius))\n      );\n    }\n  }\n\n  /*\n    Return the points in the correct winding order: begin on the left side, then\n    continue around the end cap, then come back along the right side, and finally\n    complete the start cap.\n  */\n\n  return leftPts.concat(endCap, rightPts.reverse(), startCap);\n}\n"]}