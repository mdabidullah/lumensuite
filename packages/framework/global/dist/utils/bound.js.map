{"version":3,"file":"bound.js","sourceRoot":"","sources":["../../src/utils/bound.ts"],"names":[],"mappings":"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","sourcesContent":["import { getBoundsFromPoints, getBoundsWithRotation } from './math.js';\nimport { Bound, type IBound, type IVec } from './model/index.js';\n\nfunction getExpandedBound(a: IBound, b: IBound): IBound {\n  const minX = Math.min(a.x, b.x);\n  const minY = Math.min(a.y, b.y);\n  const maxX = Math.max(a.x + a.w, b.x + b.w);\n  const maxY = Math.max(a.y + a.h, b.y + b.h);\n  const width = Math.abs(maxX - minX);\n  const height = Math.abs(maxY - minY);\n\n  return {\n    x: minX,\n    y: minY,\n    w: width,\n    h: height,\n  };\n}\n\nexport function getCommonBound(bounds: IBound[]): Bound | null {\n  if (!bounds.length) {\n    return null;\n  }\n  if (bounds.length === 1) {\n    const { x, y, w, h } = bounds[0];\n    return new Bound(x, y, w, h);\n  }\n\n  let result = bounds[0];\n\n  for (let i = 1; i < bounds.length; i++) {\n    result = getExpandedBound(result, bounds[i]);\n  }\n\n  return new Bound(result.x, result.y, result.w, result.h);\n}\n\nexport function getElementsBound(bounds: IBound[]): Bound {\n  let minX = Number.POSITIVE_INFINITY;\n  let minY = Number.POSITIVE_INFINITY;\n  let maxX = Number.NEGATIVE_INFINITY;\n  let maxY = Number.NEGATIVE_INFINITY;\n\n  bounds.forEach(ele => {\n    const b = getBoundsWithRotation(ele);\n\n    minX = Math.min(minX, b.x);\n    minY = Math.min(minY, b.y);\n    maxX = Math.max(maxX, b.x + b.w);\n    maxY = Math.max(maxY, b.y + b.h);\n  });\n\n  return new Bound(minX, minY, maxX - minX, maxY - minY);\n}\n\nexport function getBoundFromPoints(points: IVec[]) {\n  const { minX, minY, width, height } = getBoundsFromPoints(points);\n  return new Bound(minX, minY, width, height);\n}\n\nexport function inflateBound(bound: IBound, delta: number) {\n  const half = delta / 2;\n\n  const newBound = new Bound(\n    bound.x - half,\n    bound.y - half,\n    bound.w + delta,\n    bound.h + delta\n  );\n\n  if (newBound.w <= 0 || newBound.h <= 0) {\n    throw new Error('Invalid delta range or bound size.');\n  }\n\n  return newBound;\n}\n\nexport function transformPointsToNewBound<T extends { x: number; y: number }>(\n  points: T[],\n  oldBound: IBound,\n  oldMargin: number,\n  newBound: IBound,\n  newMargin: number\n) {\n  const wholeOldMargin = oldMargin * 2;\n  const wholeNewMargin = newMargin * 2;\n  const oldW = Math.max(oldBound.w - wholeOldMargin, 1);\n  const oldH = Math.max(oldBound.h - wholeOldMargin, 1);\n  const newW = Math.max(newBound.w - wholeNewMargin, 1);\n  const newH = Math.max(newBound.h - wholeNewMargin, 1);\n\n  const transformedPoints = points.map(p => {\n    return {\n      ...p,\n      x: newW * ((p.x - oldMargin) / oldW) + newMargin,\n      y: newH * ((p.y - oldMargin) / oldH) + newMargin,\n    } as T;\n  });\n\n  return {\n    points: transformedPoints,\n    bound: new Bound(\n      newBound.x,\n      newBound.y,\n      newW + wholeNewMargin,\n      newH + wholeNewMargin\n    ),\n  };\n}\n"]}