{"version":3,"file":"delta.js","sourceRoot":"","sources":["../../src/services/delta.ts"],"names":[],"mappings":"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","sourcesContent":["import { html, render } from 'lit';\nimport { repeat } from 'lit/directives/repeat.js';\n\nimport type { VLine } from '../index.js';\nimport type { InlineEditor } from '../inline-editor.js';\nimport type { DeltaEntry, DeltaInsert, InlineRange } from '../types.js';\nimport type { BaseTextAttributes } from '../utils/index.js';\n\nimport {\n  deltaInsertsToChunks,\n  transformDeltasToEmbedDeltas,\n} from '../utils/index.js';\nimport { isInlineRangeIntersect } from '../utils/inline-range.js';\n\nexport class DeltaService<TextAttributes extends BaseTextAttributes> {\n  /**\n   * Here are examples of how this function computes and gets the delta.\n   *\n   * We have such a text:\n   * ```\n   * [\n   *   {\n   *      insert: 'aaa',\n   *      attributes: { bold: true },\n   *   },\n   *   {\n   *      insert: 'bbb',\n   *      attributes: { italic: true },\n   *   },\n   * ]\n   * ```\n   *\n   * `getDeltaByRangeIndex(0)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n   *\n   * `getDeltaByRangeIndex(1)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n   *\n   * `getDeltaByRangeIndex(3)` returns `{ insert: 'aaa', attributes: { bold: true } }`.\n   *\n   * `getDeltaByRangeIndex(4)` returns `{ insert: 'bbb', attributes: { italic: true } }`.\n   */\n  getDeltaByRangeIndex = (rangeIndex: number) => {\n    const deltas = this.deltas;\n\n    let index = 0;\n    for (const delta of deltas) {\n      if (index + delta.insert.length >= rangeIndex) {\n        return delta;\n      }\n      index += delta.insert.length;\n    }\n\n    return null;\n  };\n\n  /**\n   * Here are examples of how this function computes and gets the deltas.\n   *\n   * We have such a text:\n   * ```\n   * [\n   *   {\n   *      insert: 'aaa',\n   *      attributes: { bold: true },\n   *   },\n   *   {\n   *      insert: 'bbb',\n   *      attributes: { italic: true },\n   *   },\n   *   {\n   *      insert: 'ccc',\n   *      attributes: { underline: true },\n   *   },\n   * ]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 0, length: 0 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 0, length: 1 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 0, length: 4 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 3, length: 1 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n   * ```\n   *\n   * `getDeltasByInlineRange({ index: 3, length: 3 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }]]\n   * ```\n   *\n   *  `getDeltasByInlineRange({ index: 3, length: 4 })` returns\n   * ```\n   * [{ insert: 'aaa', attributes: { bold: true }, }, { index: 0, length: 3, }],\n   *  [{ insert: 'bbb', attributes: { italic: true }, }, { index: 3, length: 3, }],\n   *  [{ insert: 'ccc', attributes: { underline: true }, }, { index: 6, length: 3, }]]\n   * ```\n   */\n  getDeltasByInlineRange = (\n    inlineRange: InlineRange\n  ): DeltaEntry<TextAttributes>[] => {\n    return this.mapDeltasInInlineRange(\n      inlineRange,\n      (delta, index): DeltaEntry<TextAttributes> => [\n        delta,\n        { index, length: delta.insert.length },\n      ]\n    );\n  };\n\n  mapDeltasInInlineRange = <Result>(\n    inlineRange: InlineRange,\n    callback: (\n      delta: DeltaInsert<TextAttributes>,\n      rangeIndex: number,\n      deltaIndex: number\n    ) => Result\n  ) => {\n    const deltas = this.deltas;\n    const result: Result[] = [];\n\n    deltas.reduce((rangeIndex, delta, deltaIndex) => {\n      const length = delta.insert.length;\n      const from = inlineRange.index - length;\n      const to = inlineRange.index + inlineRange.length;\n\n      const deltaInRange =\n        rangeIndex >= from &&\n        (rangeIndex < to ||\n          (inlineRange.length === 0 && rangeIndex === inlineRange.index));\n\n      if (deltaInRange) {\n        const value = callback(delta, rangeIndex, deltaIndex);\n        result.push(value);\n      }\n\n      return rangeIndex + length;\n    }, 0);\n\n    return result;\n  };\n\n  // render current deltas to VLines\n  render = async (syncInlineRange = true) => {\n    if (!this.editor.mounted) return;\n\n    this.editor.slots.render.emit();\n\n    const rootElement = this.editor.rootElement;\n    const chunks = deltaInsertsToChunks(this.deltas);\n\n    let deltaIndex = 0;\n    // every chunk is a line\n    const lines = chunks.map((chunk, lineIndex) => {\n      if (lineIndex > 0) {\n        deltaIndex += 1; // for '\\n'\n      }\n\n      if (chunk.length > 0) {\n        const elements: VLine['elements'] = chunk.map(delta => {\n          const startOffset = deltaIndex;\n          deltaIndex += delta.insert.length;\n          const endOffset = deltaIndex;\n\n          const inlineRange = this.editor.getInlineRange();\n          const selected =\n            !!inlineRange &&\n            isInlineRangeIntersect(inlineRange, {\n              index: startOffset,\n              length: endOffset - startOffset,\n            });\n\n          return [\n            html`<v-element\n              .selected=${selected}\n              .delta=${{\n                insert: delta.insert,\n                attributes: this.editor.attributeService.normalizeAttributes(\n                  delta.attributes\n                ),\n              }}\n              .startOffset=${startOffset}\n              .endOffset=${endOffset}\n              .lineIndex=${lineIndex}\n            ></v-element>`,\n            delta,\n          ];\n        });\n\n        return html`<v-line\n          .elements=${elements}\n          .index=${lineIndex}\n        ></v-line>`;\n      } else {\n        return html`<v-line .elements=${[]} .index=${lineIndex}></v-line>`;\n      }\n    });\n\n    try {\n      render(\n        repeat(\n          lines.map((line, i) => ({ line, index: i })),\n          entry => entry.index,\n          entry => entry.line\n        ),\n        rootElement\n      );\n    } catch (_) {\n      // Lit may be crashed by IME input and we need to rerender whole editor for it\n      this.editor.rerenderWholeEditor();\n      await this.editor.waitForUpdate();\n    }\n\n    await this.editor.waitForUpdate();\n\n    if (syncInlineRange) {\n      // We need to synchronize the selection immediately after rendering is completed,\n      // otherwise there is a possibility of an error in the cursor position\n      this.editor.rangeService.syncInlineRange();\n    }\n\n    this.editor.slots.renderComplete.emit();\n  };\n\n  get deltas() {\n    return transformDeltasToEmbedDeltas(this.editor, this.editor.yTextDeltas);\n  }\n\n  constructor(readonly editor: InlineEditor<TextAttributes>) {}\n}\n"]}