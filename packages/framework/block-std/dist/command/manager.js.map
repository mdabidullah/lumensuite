{"version":3,"file":"manager.js","sourceRoot":"","sources":["../../src/command/manager.ts"],"names":[],"mappings":"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","sourcesContent":["import { LumenSuiteError, ErrorCode } from '@lumensuite/global/exceptions';\n\nimport type {\n  Chain,\n  Command,\n  ExecCommandResult,\n  IfAllKeysOptional,\n  InDataOfCommand,\n  InitCommandCtx,\n} from './types.js';\n\nimport { LifeCycleWatcher } from '../extension/index.js';\nimport { CommandIdentifier } from '../identifier.js';\nimport { cmdSymbol } from './consts.js';\n\n/**\n * Command manager to manage all commands\n *\n * Commands are functions that take a context and a next function as arguments\n *\n * ```ts\n * const myCommand: Command<'count', 'count'> = (ctx, next) => {\n *  const count = ctx.count || 0;\n *\n *  const success = someOperation();\n *  if (success) {\n *    return next({ count: count + 1 });\n *  }\n *  // if the command is not successful, you can return without calling next\n *  return;\n * ```\n *\n * You should always add the command to the global interface `LumenSuite.Commands`\n * ```ts\n * declare global {\n *   namespace LumenSuite {\n *     interface Commands {\n *       'myCommand': typeof myCommand\n *     }\n *   }\n * }\n * ```\n *\n * Command input and output data can be defined in the `Command` type\n *\n * ```ts\n * // input: ctx.firstName, ctx.lastName\n * // output: ctx.fullName\n * const myCommand: Command<'firstName' | 'lastName', 'fullName'> = (ctx, next) => {\n *   const { firstName, lastName } = ctx;\n *   const fullName = `${firstName} ${lastName}`;\n *   return next({ fullName });\n * }\n *\n * declare global {\n *   namespace LumenSuite {\n *     interface CommandContext {\n *       // All command input and output data should be defined here\n *       // The keys should be optional\n *       firstName?: string;\n *       lastName?: string;\n *       fullName?: string;\n *     }\n *   }\n * }\n *\n * ```\n *\n *\n * ---\n *\n * Commands can be run in two ways:\n *\n * 1. Using `exec` method\n * `exec` is used to run a single command\n * ```ts\n * const { success, ...data } = commandManager.exec('myCommand', payload);\n * ```\n *\n * 2. Using `chain` method\n * `chain` is used to run a series of commands\n * ```ts\n * const chain = commandManager.chain();\n * const [result, data] = chain\n *   .myCommand1()\n *   .myCommand2(payload)\n *   .run();\n * ```\n *\n * ---\n *\n * Command chains will stop running if a command is not successful\n *\n * ```ts\n * const chain = commandManager.chain();\n * const [result, data] = chain\n *   .myCommand1() <-- if this fail\n *   .myCommand2(payload) <- this won't run\n *   .run();\n *\n * result <- result will be `false`\n * ```\n *\n * You can use `try` to run a series of commands and if one of them is successful, it will continue to the next command\n * ```ts\n * const chain = commandManager.chain();\n * const [result, data] = chain\n *   .try(chain => [\n *     chain.myCommand1(), <- if this fail\n *     chain.myCommand2(), <- this will run, if this success\n *     chain.myCommand3(), <- this won't run\n *   ])\n *   .run();\n * ```\n *\n * The `tryAll` method is similar to `try`, but it will run all commands even if one of them is successful\n * ```ts\n * const chain = commandManager.chain();\n * const [result, data] = chain\n *   .try(chain => [\n *     chain.myCommand1(), <- if this success\n *     chain.myCommand2(), <- this will also run\n *     chain.myCommand3(), <- so will this\n *   ])\n *   .run();\n * ```\n *\n */\nexport class CommandManager extends LifeCycleWatcher {\n  static override readonly key = 'commandManager';\n\n  private _commands = new Map<string, Command>();\n\n  private _createChain = (\n    methods: Record<LumenSuite.CommandName, unknown>,\n    _cmds: Command[]\n  ): Chain => {\n    const getCommandCtx = this._getCommandCtx;\n    const createChain = this._createChain;\n    const chain = this.chain;\n\n    return {\n      [cmdSymbol]: _cmds,\n      run: function (this: Chain) {\n        let ctx = getCommandCtx();\n        let success = false;\n        try {\n          const cmds = this[cmdSymbol];\n          ctx = runCmds(ctx as LumenSuite.CommandContext, [\n            ...cmds,\n            (_, next) => {\n              success = true;\n              next();\n            },\n          ]);\n        } catch (err) {\n          console.error(err);\n        }\n\n        return [success, ctx];\n      },\n      with: function (this: Chain, value) {\n        const cmds = this[cmdSymbol];\n        return createChain(methods, [\n          ...cmds,\n          (_, next) => next(value),\n        ]) as never;\n      },\n      inline: function (this: Chain, command) {\n        const cmds = this[cmdSymbol];\n        return createChain(methods, [...cmds, command]) as never;\n      },\n      try: function (this: Chain, fn) {\n        const cmds = this[cmdSymbol];\n        return createChain(methods, [\n          ...cmds,\n          (beforeCtx, next) => {\n            let ctx = beforeCtx;\n            const chains = fn(chain());\n\n            chains.some(chain => {\n              // inject ctx in the beginning\n              chain[cmdSymbol] = [\n                (_, next) => {\n                  next(ctx);\n                },\n                ...chain[cmdSymbol],\n              ];\n\n              const [success] = chain\n                .inline((branchCtx, next) => {\n                  ctx = { ...ctx, ...branchCtx };\n                  next();\n                })\n                .run();\n              if (success) {\n                next(ctx);\n                return true;\n              }\n              return false;\n            });\n          },\n        ]) as never;\n      },\n      tryAll: function (this: Chain, fn) {\n        const cmds = this[cmdSymbol];\n        return createChain(methods, [\n          ...cmds,\n          (beforeCtx, next) => {\n            let ctx = beforeCtx;\n            const chains = fn(chain());\n\n            let allFail = true;\n            chains.forEach(chain => {\n              // inject ctx in the beginning\n              chain[cmdSymbol] = [\n                (_, next) => {\n                  next(ctx);\n                },\n                ...chain[cmdSymbol],\n              ];\n\n              const [success] = chain\n                .inline((branchCtx, next) => {\n                  ctx = { ...ctx, ...branchCtx };\n                  next();\n                })\n                .run();\n              if (success) {\n                allFail = false;\n              }\n            });\n            if (!allFail) {\n              next(ctx);\n            }\n          },\n        ]) as never;\n      },\n      ...methods,\n    } as Chain;\n  };\n\n  private _getCommandCtx = (): InitCommandCtx => {\n    return {\n      std: this.std,\n    };\n  };\n\n  /**\n   * Create a chain to run a series of commands\n   * ```ts\n   * const chain = commandManager.chain();\n   * const [result, data] = chain\n   *   .myCommand1()\n   *   .myCommand2(payload)\n   *   .run();\n   * ```\n   * @returns [success, data] - success is a boolean to indicate if the chain is successful,\n   *   data is the final context after running the chain\n   */\n  chain = (): Chain<InitCommandCtx> => {\n    const methods = {} as Record<\n      string,\n      (data: Record<string, unknown>) => Chain\n    >;\n    const createChain = this._createChain;\n    for (const [name, command] of this._commands.entries()) {\n      methods[name] = function (\n        this: { [cmdSymbol]: Command[] },\n        data: Record<string, unknown>\n      ) {\n        const cmds = this[cmdSymbol];\n        return createChain(methods, [\n          ...cmds,\n          (ctx, next) => command({ ...ctx, ...data }, next),\n        ]);\n      };\n    }\n\n    return createChain(methods, []) as never;\n  };\n\n  /**\n   * Register a command to the command manager\n   * @param name\n   * @param command\n   * Make sure to also add the command to the global interface `LumenSuite.Commands`\n   * ```ts\n   * const myCommand: Command = (ctx, next) => {\n   *   // do something\n   * }\n   *\n   * declare global {\n   *   namespace LumenSuite {\n   *     interface Commands {\n   *       'myCommand': typeof myCommand\n   *     }\n   *   }\n   * }\n   * ```\n   */\n  add<N extends LumenSuite.CommandName>(\n    name: N,\n    command: LumenSuite.Commands[N]\n  ): CommandManager;\n\n  add(name: string, command: Command) {\n    this._commands.set(name, command);\n    return this;\n  }\n\n  override created() {\n    const add = this.add.bind(this);\n    this.std.provider.getAll(CommandIdentifier).forEach((command, key) => {\n      add(key as keyof LumenSuite.Commands, command);\n    });\n  }\n\n  /**\n   * Execute a registered command by name\n   * @param command\n   * @param payloads\n   * ```ts\n   * const { success, ...data } = commandManager.exec('myCommand', { data: 'data' });\n   * ```\n   * @returns { success, ...data } - success is a boolean to indicate if the command is successful,\n   *  data is the final context after running the command\n   */\n  exec<K extends keyof LumenSuite.Commands>(\n    command: K,\n    ...payloads: IfAllKeysOptional<\n      Omit<InDataOfCommand<LumenSuite.Commands[K]>, keyof InitCommandCtx>,\n      [\n        inData: void | Omit<\n          InDataOfCommand<LumenSuite.Commands[K]>,\n          keyof InitCommandCtx\n        >,\n      ],\n      [\n        inData: Omit<\n          InDataOfCommand<LumenSuite.Commands[K]>,\n          keyof InitCommandCtx\n        >,\n      ]\n    >\n  ): ExecCommandResult<K> & { success: boolean } {\n    const cmdFunc = this._commands.get(command);\n\n    if (!cmdFunc) {\n      throw new LumenSuiteError(\n        ErrorCode.CommandError,\n        `The command \"${command}\" not found`\n      );\n    }\n\n    const inData = payloads[0];\n    const ctx = {\n      ...this._getCommandCtx(),\n      ...inData,\n    };\n\n    let execResult = {\n      success: false,\n    } as ExecCommandResult<K> & { success: boolean };\n\n    cmdFunc(ctx, result => {\n      // @ts-ignore\n      execResult = { ...result, success: true };\n    });\n\n    return execResult;\n  }\n}\n\nfunction runCmds(ctx: LumenSuite.CommandContext, [cmd, ...rest]: Command[]) {\n  let _ctx = ctx;\n  if (cmd) {\n    cmd(ctx, data => {\n      _ctx = runCmds({ ...ctx, ...data }, rest);\n    });\n  }\n  return _ctx;\n}\n"]}