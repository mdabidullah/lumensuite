{"version":3,"file":"types.js","sourceRoot":"","sources":["../../src/command/types.ts"],"names":[],"mappings":"","sourcesContent":["// type A = {};\n// type B = { prop?: string };\n// type C = { prop: string };\n// type TestA = MakeOptionalIfEmpty<A>;  // void | {}\n// type TestB = MakeOptionalIfEmpty<B>;  // void | { prop?: string }\n// type TestC = MakeOptionalIfEmpty<C>;  // { prop: string }\nimport type { cmdSymbol } from './consts.js';\n\nexport type IfAllKeysOptional<T, Yes, No> =\n  Partial<T> extends T ? (T extends Partial<T> ? Yes : No) : No;\ntype MakeOptionalIfEmpty<T> = IfAllKeysOptional<T, void | T, T>;\n\nexport interface InitCommandCtx {\n  std: BlockSuite.Std;\n}\n\nexport type CommandKeyToData<K extends BlockSuite.CommandDataName> = Pick<\n  BlockSuite.CommandContext,\n  K\n>;\nexport type Command<\n  In extends BlockSuite.CommandDataName = never,\n  Out extends BlockSuite.CommandDataName = never,\n  InData extends object = {},\n> = (\n  ctx: CommandKeyToData<In> & InitCommandCtx & InData,\n  next: (ctx?: CommandKeyToData<Out>) => void\n) => void;\ntype Omit1<A, B> = [keyof Omit<A, keyof B>] extends [never]\n  ? void\n  : Omit<A, keyof B>;\nexport type InDataOfCommand<C> =\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  C extends Command<infer K, any, infer R> ? CommandKeyToData<K> & R : never;\ntype OutDataOfCommand<C> =\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  C extends Command<any, infer K, any> ? CommandKeyToData<K> : never;\n\ntype CommonMethods<In extends object = {}> = {\n  inline: <InlineOut extends BlockSuite.CommandDataName = never>(\n    command: Command<Extract<keyof In, BlockSuite.CommandDataName>, InlineOut>\n  ) => Chain<In & CommandKeyToData<InlineOut>>;\n  try: <InlineOut extends BlockSuite.CommandDataName = never>(\n    fn: (chain: Chain<In>) => Chain<In & CommandKeyToData<InlineOut>>[]\n  ) => Chain<In & CommandKeyToData<InlineOut>>;\n  tryAll: <InlineOut extends BlockSuite.CommandDataName = never>(\n    fn: (chain: Chain<In>) => Chain<In & CommandKeyToData<InlineOut>>[]\n  ) => Chain<In & CommandKeyToData<InlineOut>>;\n  run(): [\n    result: boolean,\n    ctx: CommandKeyToData<Extract<keyof In, BlockSuite.CommandDataName>>,\n  ];\n  with<T extends Partial<BlockSuite.CommandContext>>(value: T): Chain<In & T>;\n};\n\ntype Cmds = {\n  [cmdSymbol]: Command[];\n};\n\nexport type Chain<In extends object = {}> = CommonMethods<In> & {\n  [K in keyof BlockSuite.Commands]: (\n    data: MakeOptionalIfEmpty<\n      Omit1<InDataOfCommand<BlockSuite.Commands[K]>, In>\n    >\n  ) => Chain<In & OutDataOfCommand<BlockSuite.Commands[K]>>;\n} & Cmds;\n\nexport type ExecCommandResult<K extends keyof BlockSuite.Commands> =\n  OutDataOfCommand<BlockSuite.Commands[K]>;\n\ndeclare global {\n  namespace BlockSuite {\n    interface CommandContext extends InitCommandCtx {}\n\n    interface Commands {}\n\n    type CommandName = keyof Commands;\n    type CommandDataName = keyof CommandContext;\n\n    type CommandChain<In extends object = {}> = Chain<In & InitCommandCtx>;\n  }\n}\n"]}