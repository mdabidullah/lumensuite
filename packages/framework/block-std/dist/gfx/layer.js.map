{"version":3,"file":"layer.js","sourceRoot":"","sources":["../../src/gfx/layer.ts"],"names":[],"mappings":"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","sourcesContent":["import type { Doc } from '@blocksuite/store';\n\nimport { GfxBlockElementModel } from '@blocksuite/block-std/gfx';\nimport {\n  assertType,\n  Bound,\n  DisposableGroup,\n  last,\n  nToLast,\n  Slot,\n} from '@blocksuite/global/utils';\nimport { generateKeyBetween } from 'fractional-indexing';\n\nimport type { GfxModel } from './gfx-block-model.js';\n\nimport {\n  compare,\n  getElementIndex,\n  getLayerEndZIndex,\n  insertToOrderedArray,\n  isInRange,\n  removeFromOrderedArray,\n  SortOrder,\n  ungroupIndex,\n  updateLayersZIndex,\n} from '../utils/layer.js';\nimport {\n  type GfxContainerElement,\n  GfxPrimitiveElementModel,\n  isGfxContainerElm,\n} from './surface/element-model.js';\nimport { SurfaceBlockModel } from './surface/surface-model.js';\n\nexport type ReorderingDirection = 'front' | 'forward' | 'backward' | 'back';\n\ntype BaseLayer<T> = {\n  set: Set<T>;\n\n  elements: Array<T>;\n\n  /**\n   * fractional indexing range\n   */\n  indexes: [string, string];\n};\n\nexport type BlockLayer = BaseLayer<GfxBlockElementModel> & {\n  type: 'block';\n\n  /**\n   * The z-index of the first block in this layer.\n   *\n   * A block layer may contains multiple blocks,\n   * the block should be rendered with this `zIndex` + \"its index in the layer\" as the z-index property.\n   */\n  zIndex: number;\n};\n\nexport type CanvasLayer = BaseLayer<GfxPrimitiveElementModel> & {\n  type: 'canvas';\n\n  /**\n   * The z-index of canvas layer.\n   *\n   * A canvas layer renders all the elements in a single canvas,\n   *  this property is used to render the canvas with correct z-index.\n   */\n  zIndex: number;\n};\n\nexport type Layer = BlockLayer | CanvasLayer;\n\nexport class LayerManager {\n  static INITIAL_INDEX = 'a0';\n\n  private _disposable = new DisposableGroup();\n\n  blocks: GfxBlockElementModel[] = [];\n\n  canvasElements: GfxPrimitiveElementModel[] = [];\n\n  canvasLayers: {\n    set: Set<GfxPrimitiveElementModel>;\n    /**\n     * fractional index\n     */\n    indexes: [string, string];\n    /**\n     * z-index, used for actual rendering\n     */\n    zIndex: number;\n    elements: Array<GfxPrimitiveElementModel>;\n  }[] = [];\n\n  layers: Layer[] = [];\n\n  slots = {\n    layerUpdated: new Slot<{\n      type: 'delete' | 'add' | 'update';\n      initiatingElement: GfxModel;\n    }>(),\n  };\n\n  constructor(\n    private _doc: Doc,\n    private _surface: SurfaceBlockModel | null,\n    options: {\n      watch: boolean;\n    } = { watch: true }\n  ) {\n    this._reset();\n\n    if (options?.watch) {\n      this.watch({\n        doc: _doc,\n        surface: _surface,\n      });\n    }\n  }\n\n  private _buildCanvasLayers() {\n    const canvasLayers = this.layers\n      .filter<CanvasLayer>(\n        (layer): layer is CanvasLayer => layer.type === 'canvas'\n      )\n      .map(layer => {\n        return {\n          set: layer.set,\n          elements: layer.elements,\n          zIndex: layer.zIndex,\n          indexes: layer.indexes,\n        };\n      }) as LayerManager['canvasLayers'];\n\n    if (!canvasLayers.length || last(this.layers)?.type !== 'canvas') {\n      canvasLayers.push({\n        set: new Set(),\n        elements: [],\n        zIndex: 0,\n        indexes: [LayerManager.INITIAL_INDEX, LayerManager.INITIAL_INDEX],\n      });\n    }\n\n    this.canvasLayers = canvasLayers;\n  }\n\n  private _getModelType(element: GfxModel): 'block' | 'canvas' {\n    return 'flavour' in element ? 'block' : 'canvas';\n  }\n\n  private _initLayers() {\n    let blockIdx = 0;\n    let canvasIdx = 0;\n    const layers: LayerManager['layers'] = [];\n    let curLayer: LayerManager['layers'][number] | undefined;\n    let currentCSSZindex = 1;\n\n    const pushCurLayer = () => {\n      if (curLayer) {\n        curLayer.indexes = [\n          getElementIndex(curLayer.elements[0]),\n          getElementIndex(last(curLayer.elements)!),\n        ];\n        curLayer.zIndex = currentCSSZindex;\n        layers.push(curLayer as LayerManager['layers'][number]);\n\n        currentCSSZindex +=\n          curLayer.type === 'block' ? curLayer.elements.length : 1;\n      }\n    };\n    const addLayer = (type: 'canvas' | 'block') => {\n      pushCurLayer();\n      curLayer =\n        type === 'canvas'\n          ? ({\n              type,\n              indexes: [LayerManager.INITIAL_INDEX, LayerManager.INITIAL_INDEX],\n              zIndex: 0,\n              set: new Set(),\n              elements: [],\n              bound: new Bound(),\n            } as CanvasLayer)\n          : ({\n              type,\n              indexes: [LayerManager.INITIAL_INDEX, LayerManager.INITIAL_INDEX],\n              zIndex: 0,\n              set: new Set(),\n              elements: [],\n            } as BlockLayer);\n    };\n\n    while (\n      blockIdx < this.blocks.length ||\n      canvasIdx < this.canvasElements.length\n    ) {\n      const curBlock = this.blocks[blockIdx];\n      const curCanvas = this.canvasElements[canvasIdx];\n\n      if (!curBlock && !curCanvas) {\n        break;\n      }\n\n      if (!curBlock) {\n        if (curLayer?.type !== 'canvas') {\n          addLayer('canvas');\n        }\n        assertType<CanvasLayer>(curLayer);\n\n        const remains = this.canvasElements.slice(canvasIdx);\n\n        curLayer!.elements = curLayer.elements.concat(remains);\n        remains.forEach(element => (curLayer as CanvasLayer).set.add(element));\n\n        break;\n      }\n\n      if (!curCanvas) {\n        if (curLayer?.type !== 'block') {\n          addLayer('block');\n        }\n\n        assertType<BlockLayer>(curLayer);\n\n        const remains = this.blocks.slice(blockIdx);\n\n        curLayer.elements = curLayer.elements.concat(remains);\n        remains.forEach(block => (curLayer as BlockLayer).set.add(block));\n\n        break;\n      }\n\n      const order = compare(curBlock, curCanvas);\n\n      switch (order) {\n        case -1:\n          if (curLayer?.type !== 'block') {\n            addLayer('block');\n          }\n\n          assertType<BlockLayer>(curLayer);\n\n          curLayer!.set.add(curBlock);\n          curLayer!.elements.push(curBlock);\n\n          ++blockIdx;\n\n          break;\n        case 1:\n          if (curLayer?.type !== 'canvas') {\n            addLayer('canvas');\n          }\n\n          assertType<CanvasLayer>(curLayer);\n\n          curLayer!.set.add(curCanvas);\n          curLayer!.elements.push(curCanvas);\n\n          ++canvasIdx;\n\n          break;\n        case 0:\n          if (!curLayer) {\n            addLayer('block');\n          }\n\n          if (curLayer!.type === 'block') {\n            curLayer!.set.add(curBlock);\n            curLayer!.elements.push(curBlock);\n\n            ++blockIdx;\n          } else {\n            curLayer!.set.add(curCanvas);\n            curLayer!.elements.push(curCanvas);\n\n            ++canvasIdx;\n          }\n          break;\n      }\n    }\n\n    if (curLayer && curLayer.elements.length) {\n      pushCurLayer();\n    }\n\n    this.layers = layers;\n  }\n\n  private _insertIntoLayer(target: GfxModel, type: 'block' | 'canvas') {\n    if (this.layers.length === 0) {\n      this._initLayers();\n      return;\n    }\n\n    const layers = this.layers;\n    let cur = layers.length - 1;\n\n    const addToLayer = (\n      layer: Layer,\n      element: GfxModel,\n      position: number | 'tail'\n    ) => {\n      assertType<CanvasLayer>(layer);\n      assertType<GfxPrimitiveElementModel>(element);\n\n      if (position === 'tail') {\n        layer.elements.push(element);\n      } else {\n        layer.elements.splice(position, 0, element);\n      }\n\n      layer.set.add(element);\n\n      if (\n        position === 'tail' ||\n        position === 0 ||\n        position === layer.elements.length - 1\n      ) {\n        layer.indexes = [\n          getElementIndex(layer.elements[0]),\n          getElementIndex(last(layer.elements)!),\n        ];\n      }\n    };\n    const createLayer = (\n      type: 'block' | 'canvas',\n      targets: GfxModel[],\n      curZIndex: number\n    ): Layer => {\n      const newLayer = {\n        type,\n        set: new Set(targets),\n        indexes: [\n          getElementIndex(targets[0]),\n          getElementIndex(last(targets)!),\n        ] as [string, string],\n        zIndex: curZIndex + 1,\n        elements: targets,\n      } as BlockLayer;\n\n      return newLayer as Layer;\n    };\n\n    if (\n      [SortOrder.AFTER, SortOrder.SAME].includes(\n        compare(target, last(last(this.layers)!.elements)!)\n      )\n    ) {\n      const layer = last(this.layers);\n\n      if (layer?.type === type) {\n        addToLayer(layer, target, 'tail');\n        updateLayersZIndex(layers, cur);\n      } else {\n        this.layers.push(\n          createLayer(\n            type,\n            [target],\n            getLayerEndZIndex(layers, layers.length - 1)\n          )\n        );\n      }\n    } else {\n      while (cur > -1) {\n        const layer = layers[cur];\n        const layerElements = layer.elements;\n\n        if (isInRange([layerElements[0], last(layerElements)!], target)) {\n          const insertIdx = layerElements.findIndex((_, idx) => {\n            const pre = layerElements[idx - 1];\n            return (\n              compare(target, layerElements[idx]) < 0 &&\n              (!pre || compare(target, pre) >= 0)\n            );\n          });\n\n          if (layer.type === type) {\n            addToLayer(layer, target, insertIdx);\n            updateLayersZIndex(layers, cur);\n          } else {\n            const splicedElements = layer.elements.splice(insertIdx);\n            layer.set = new Set(layer.elements as GfxPrimitiveElementModel[]);\n\n            layers.splice(\n              cur + 1,\n              0,\n              createLayer(layer.type, splicedElements, 1)\n            );\n            layers.splice(cur + 1, 0, createLayer(type, [target], 1));\n            updateLayersZIndex(layers, cur);\n          }\n          break;\n        } else {\n          const nextLayer = layers[cur - 1];\n\n          if (!nextLayer || compare(target, last(nextLayer.elements)!) >= 0) {\n            if (layer.type === type) {\n              addToLayer(layer, target, 0);\n              updateLayersZIndex(layers, cur);\n            } else {\n              if (nextLayer) {\n                addToLayer(nextLayer, target, 'tail');\n                updateLayersZIndex(layers, cur - 1);\n              } else {\n                layers.unshift(createLayer(type, [target], 1));\n                updateLayersZIndex(layers, 0);\n              }\n            }\n\n            break;\n          }\n        }\n\n        --cur;\n      }\n    }\n  }\n\n  private _removeFromLayer(target: GfxModel, type: 'block' | 'canvas') {\n    const layers = this.layers;\n    const index = layers.findIndex(layer => {\n      if (layer.type !== type) return false;\n\n      assertType<CanvasLayer>(layer);\n      assertType<GfxPrimitiveElementModel>(target);\n\n      if (layer.set.has(target)) {\n        layer.set.delete(target);\n        const idx = layer.elements.indexOf(target);\n        if (idx !== -1) {\n          layer.elements.splice(layer.elements.indexOf(target), 1);\n\n          if (layer.elements.length) {\n            layer.indexes = [\n              getElementIndex(layer.elements[0]),\n              getElementIndex(last(layer.elements)!),\n            ];\n          }\n        }\n\n        return true;\n      }\n\n      return false;\n    });\n\n    if (index === -1) return;\n\n    const isDeletedAtEdge = index === 0 || index === layers.length - 1;\n\n    if (layers[index].set.size === 0) {\n      if (isDeletedAtEdge) {\n        layers.splice(index, 1);\n\n        if (layers[index]) {\n          updateLayersZIndex(layers, index);\n        }\n      } else {\n        const lastLayer = layers[index - 1] as CanvasLayer;\n        const nextLayer = layers[index + 1] as CanvasLayer;\n\n        lastLayer.elements = lastLayer.elements.concat(nextLayer.elements);\n        lastLayer.set = new Set(lastLayer.elements);\n\n        layers.splice(index, 2);\n        updateLayersZIndex(layers, index - 1);\n      }\n      return;\n    }\n\n    updateLayersZIndex(layers, index);\n  }\n\n  private _reset() {\n    const elements = (\n      this._doc\n        .getBlocks()\n        .filter(\n          model =>\n            model instanceof GfxBlockElementModel &&\n            (model.parent instanceof SurfaceBlockModel ||\n              model.parent?.role === 'root')\n        ) as GfxModel[]\n    ).concat(this._surface?.elementModels ?? []);\n\n    this.canvasElements = [];\n    this.blocks = [];\n\n    elements.forEach(element => {\n      if (element instanceof GfxPrimitiveElementModel) {\n        this.canvasElements.push(element);\n      } else {\n        this.blocks.push(element);\n      }\n    });\n\n    this.canvasElements.sort(compare);\n    this.blocks.sort(compare);\n\n    this._initLayers();\n    this._buildCanvasLayers();\n  }\n\n  /**\n   * @returns a boolean value to indicate whether the layers have been updated\n   */\n  private _updateLayer(element: GfxModel, props?: Record<string, unknown>) {\n    const modelType = this._getModelType(element);\n\n    const indexChanged = !props || 'index' in props;\n    const childIdsChanged = props && 'childIds' in props;\n    const shouldUpdateGroupChildren =\n      isGfxContainerElm(element) && (indexChanged || childIdsChanged);\n    const updateArray = (array: GfxModel[], element: GfxModel) => {\n      if (!indexChanged) return;\n      removeFromOrderedArray(array, element);\n      insertToOrderedArray(array, element);\n    };\n\n    if (shouldUpdateGroupChildren) {\n      this._reset();\n      return true;\n    }\n\n    if (modelType === 'canvas') {\n      updateArray(this.canvasElements, element);\n    } else {\n      updateArray(this.blocks, element);\n    }\n\n    if (indexChanged || childIdsChanged) {\n      this._removeFromLayer(element as GfxModel, modelType);\n      this._insertIntoLayer(element as GfxModel, modelType);\n      return true;\n    }\n\n    return false;\n  }\n\n  add(element: GfxModel) {\n    const modelType = this._getModelType(element);\n    const isGroup = isGfxContainerElm(element);\n\n    if (modelType === 'canvas') {\n      if (isGroup) {\n        (element as GfxContainerElement).childElements.forEach(child => {\n          if (child && this._getModelType(child) === 'canvas') {\n            removeFromOrderedArray(this.canvasElements, child);\n          }\n        });\n      }\n      insertToOrderedArray(this.canvasElements, element);\n    } else {\n      insertToOrderedArray(this.blocks, element);\n    }\n\n    this._insertIntoLayer(element as GfxModel, modelType);\n    if (isGroup) {\n      (element as GfxContainerElement).childElements.forEach(\n        child => child && this._updateLayer(child)\n      );\n    }\n    this._buildCanvasLayers();\n    this.slots.layerUpdated.emit({\n      type: 'add',\n      initiatingElement: element,\n    });\n  }\n\n  /**\n   * Pass to the `Array.sort` to  sort the elements by their index\n   */\n  compare(a: GfxModel, b: GfxModel) {\n    return compare(a, b);\n  }\n\n  /**\n   * In some cases, we need to generate a bunch of indexes in advance before acutally adding the elements to the layer manager.\n   * Eg. when importing a template. The `generateIndex` is a function only depends on the current state of the manager.\n   * So we cannot use it because it will always return the same index if the element is not added to manager.\n   *\n   * This function return a index generator that can \"remember\" the index it generated without actually adding the element to the manager.\n   *\n   * @note The generator cannot work with `group` element.\n   *\n   * @param ignoreRule If true, the generator will not distinguish between `block` and `canvas` elements.\n   * @returns\n   */\n  createIndexGenerator(ignoreRule: boolean = false) {\n    const manager = new LayerManager(this._doc, this._surface, {\n      watch: false,\n    });\n\n    return (elementType: string) => {\n      if (ignoreRule) {\n        elementType = 'shape';\n      }\n\n      if (elementType === 'group') elementType = 'shape';\n\n      const typeField = this._surface?.registeredElementTypes.includes(\n        elementType\n      )\n        ? 'type'\n        : 'flavour';\n      const idx = manager.generateIndex(elementType);\n      const bound = new Bound(0, 0, 10, 10);\n\n      const mockedFakeElement = {\n        index: idx,\n        [typeField]: elementType,\n        x: 0,\n        y: 0,\n        w: 10,\n        h: 10,\n        elementBound: bound,\n        xywh: '[0, 0, 10, 10]',\n        get group() {\n          return null;\n        },\n        get groups() {\n          return [];\n        },\n      };\n\n      manager.add(mockedFakeElement as unknown as GfxModel);\n\n      return idx;\n    };\n  }\n\n  delete(element: GfxModel) {\n    let deleteType: 'canvas' | 'block' | undefined = undefined;\n    const isGroup = isGfxContainerElm(element);\n\n    if (isGroup) {\n      this._reset();\n      this.slots.layerUpdated.emit({\n        type: 'delete',\n        initiatingElement: element as GfxModel,\n      });\n      return;\n    }\n\n    if (element instanceof GfxPrimitiveElementModel) {\n      deleteType = 'canvas';\n      removeFromOrderedArray(this.canvasElements, element);\n    } else {\n      deleteType = 'block';\n      removeFromOrderedArray(this.blocks, element);\n    }\n\n    if (deleteType) {\n      this._removeFromLayer(element, deleteType);\n      this._buildCanvasLayers();\n      this.slots.layerUpdated.emit({\n        type: 'delete',\n        initiatingElement: element,\n      });\n    }\n  }\n\n  dispose() {\n    this.slots.layerUpdated.dispose();\n  }\n\n  generateIndex(elementType: string): string {\n    const type = this._surface?.registeredElementTypes.includes(elementType)\n      ? 'canvas'\n      : 'block';\n\n    if (type === 'canvas') {\n      const lastIndex = last(this.layers)?.indexes[1];\n\n      return lastIndex\n        ? generateKeyBetween(ungroupIndex(lastIndex), null)\n        : LayerManager.INITIAL_INDEX;\n    }\n\n    const lastLayer = last(this.layers);\n\n    if (!lastLayer) return LayerManager.INITIAL_INDEX;\n\n    assertType<string>(lastLayer);\n\n    if (lastLayer.type === 'canvas') {\n      const secondLastLayer = nToLast(this.layers, 2);\n      const secondLastLayerIndex = secondLastLayer\n        ? ungroupIndex(secondLastLayer.indexes[1])\n        : null;\n      const lastLayerIndex = ungroupIndex(lastLayer.indexes[0]);\n\n      return generateKeyBetween(\n        secondLastLayerIndex,\n        secondLastLayerIndex && secondLastLayerIndex >= lastLayerIndex\n          ? null\n          : lastLayerIndex\n      );\n    }\n\n    return generateKeyBetween(lastLayer.indexes[1], null);\n  }\n\n  getCanvasLayers() {\n    return this.canvasLayers;\n  }\n\n  getReorderedIndex(element: GfxModel, direction: ReorderingDirection): string {\n    const group = (element.group as GfxContainerElement) || null;\n\n    let elements: GfxModel[];\n\n    if (group !== null) {\n      elements = group.childElements;\n\n      elements.sort(compare);\n    } else {\n      elements = this.layers.reduce(\n        (pre: GfxModel[], current) =>\n          pre.concat(current.elements.filter(element => element.group == null)),\n        []\n      );\n    }\n\n    const currentIdx = elements.indexOf(element);\n\n    switch (direction) {\n      case 'forward':\n      case 'front':\n        if (currentIdx === -1 || currentIdx === elements.length - 1)\n          return element.index;\n\n        {\n          const next =\n            direction === 'forward'\n              ? elements[currentIdx + 1]\n              : elements[elements.length - 1];\n          const next2 =\n            direction === 'forward' ? elements[currentIdx + 2] : null;\n\n          return generateKeyBetween(\n            next.index,\n            next2?.index\n              ? next.index < next2.index\n                ? next2.index\n                : null\n              : null\n          );\n        }\n      case 'backward':\n      case 'back':\n        if (currentIdx === -1 || currentIdx === 0) return element.index;\n\n        {\n          const pre =\n            direction === 'backward' ? elements[currentIdx - 1] : elements[0];\n          const pre2 =\n            direction === 'backward' ? elements[currentIdx - 2] : null;\n\n          return generateKeyBetween(\n            !pre2 || pre2?.index >= pre.index ? null : pre2.index,\n            pre.index\n          );\n        }\n    }\n  }\n\n  getZIndex(element: GfxModel): number {\n    // @ts-ignore\n    const layer = this.layers.find(layer => layer.set.has(element));\n\n    if (!layer) return -1;\n\n    // @ts-ignore\n    return layer.zIndex + layer.elements.indexOf(element);\n  }\n\n  update(element: GfxModel, props?: Record<string, unknown>) {\n    if (this._updateLayer(element, props)) {\n      this._buildCanvasLayers();\n      this.slots.layerUpdated.emit({\n        type: 'update',\n        initiatingElement: element,\n      });\n    }\n  }\n\n  watch(blocks: { doc?: Doc; surface: SurfaceBlockModel | null }) {\n    const { doc, surface } = blocks;\n\n    if (doc) {\n      this._disposable.add(\n        doc.slots.blockUpdated.on(payload => {\n          if (payload.type === 'add') {\n            const block = doc.getBlockById(payload.id)!;\n\n            if (\n              block instanceof GfxBlockElementModel &&\n              (block.parent instanceof SurfaceBlockModel ||\n                block.parent?.role === 'root') &&\n              this.blocks.indexOf(block) === -1\n            ) {\n              this.add(block as GfxBlockElementModel);\n            }\n          }\n          if (payload.type === 'update') {\n            const block = doc.getBlockById(payload.id)!;\n\n            if (\n              (payload.props.key === 'index' ||\n                payload.props.key === 'childIds') &&\n              block instanceof GfxBlockElementModel &&\n              (block.parent instanceof SurfaceBlockModel ||\n                block.parent?.role === 'root')\n            ) {\n              this.update(block as GfxBlockElementModel, {\n                [payload.props.key]: true,\n              });\n            }\n          }\n          if (payload.type === 'delete') {\n            const block = doc.getBlockById(payload.id);\n\n            if (block instanceof GfxBlockElementModel) {\n              this.delete(block as GfxBlockElementModel);\n            }\n          }\n        })\n      );\n    }\n\n    if (surface) {\n      if (this._surface !== surface) {\n        this._surface = surface;\n      }\n\n      this._disposable.add(\n        surface.elementAdded.on(payload =>\n          this.add(surface.getElementById(payload.id)!)\n        )\n      );\n      this._disposable.add(\n        surface.elementUpdated.on(payload => {\n          if (payload.props['index'] || payload.props['childIds']) {\n            this.update(surface.getElementById(payload.id)!, payload.props);\n          }\n        })\n      );\n      this._disposable.add(\n        surface.elementRemoved.on(payload => this.delete(payload.model!))\n      );\n\n      surface.elementModels.forEach(el => this.add(el));\n    }\n  }\n}\n"]}