{"version":3,"file":"schema.js","sourceRoot":"","sources":["../../src/schema/schema.ts"],"names":[],"mappings":"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","sourcesContent":["import type * as Y from 'yjs';\n\nimport { minimatch } from 'minimatch';\n\nimport type { BlockSchemaType } from './base.js';\n\nimport { SCHEMA_NOT_FOUND_MESSAGE } from '../consts.js';\nimport { collectionMigrations, docMigrations } from '../migration/index.js';\nimport { Block, type YBlock } from '../store/doc/block/index.js';\nimport { BlockSchema } from './base.js';\nimport { MigrationError, SchemaValidateError } from './error.js';\n\nexport class Schema {\n  private _upgradeBlockVersions = (rootData: Y.Doc) => {\n    const meta = rootData.getMap('meta');\n    const blockVersions = meta.get('blockVersions') as Y.Map<number>;\n    if (!blockVersions) {\n      return;\n    }\n    blockVersions.forEach((version, flavour) => {\n      const currentSchema = this.flavourSchemaMap.get(flavour);\n      if (currentSchema && version !== currentSchema.version) {\n        blockVersions.set(flavour, currentSchema.version);\n      }\n    });\n  };\n\n  readonly flavourSchemaMap = new Map<string, BlockSchemaType>();\n\n  upgradeBlock = (\n    flavour: string,\n    oldVersion: number,\n    blockData: Y.Map<unknown>\n  ) => {\n    try {\n      const currentSchema = this.flavourSchemaMap.get(flavour);\n      if (!currentSchema) {\n        throw new MigrationError(`schema for flavour: ${flavour} not found`);\n      }\n      const { onUpgrade, version } = currentSchema;\n      if (!onUpgrade) {\n        return;\n      }\n\n      const block = new Block(this, blockData as YBlock);\n\n      return onUpgrade(block.model, oldVersion, version);\n    } catch (err) {\n      throw new MigrationError(`upgrade block ${flavour} failed.\n          ${err}`);\n    }\n  };\n\n  upgradeCollection = (rootData: Y.Doc) => {\n    this._upgradeBlockVersions(rootData);\n    collectionMigrations.forEach(migration => {\n      try {\n        if (migration.condition(rootData)) {\n          migration.migrate(rootData);\n        }\n      } catch (err) {\n        console.error(err);\n        throw new MigrationError(migration.desc);\n      }\n    });\n  };\n\n  upgradeDoc = (\n    oldPageVersion: number,\n    oldBlockVersions: Record<string, number>,\n    docData: Y.Doc\n  ) => {\n    // block migrations\n    const blocks = docData.getMap('blocks') as Y.Map<Y.Map<unknown>>;\n    Array.from(blocks.values()).forEach(block => {\n      const flavour = block.get('sys:flavour') as string;\n      const currentVersion =\n        (block.get('sys:version') as number) ?? oldBlockVersions[flavour] ?? 0;\n      if (currentVersion == null) {\n        throw new MigrationError(\n          `version for flavour ${flavour} not found in block`\n        );\n      }\n      this.upgradeBlock(flavour, currentVersion, block);\n    });\n\n    // doc migrations\n    docMigrations.forEach(migration => {\n      try {\n        if (migration.condition(oldPageVersion, docData)) {\n          migration.migrate(oldPageVersion, docData);\n        }\n      } catch (err) {\n        throw new MigrationError(`${migration.desc}\n            ${err}`);\n      }\n    });\n  };\n\n  validate = (\n    flavour: string,\n    parentFlavour?: string,\n    childFlavours?: string[]\n  ): void => {\n    const schema = this.flavourSchemaMap.get(flavour);\n    if (!schema) {\n      throw new SchemaValidateError(flavour, SCHEMA_NOT_FOUND_MESSAGE);\n    }\n\n    const validateChildren = () => {\n      childFlavours?.forEach(childFlavour => {\n        const childSchema = this.flavourSchemaMap.get(childFlavour);\n        if (!childSchema) {\n          throw new SchemaValidateError(childFlavour, SCHEMA_NOT_FOUND_MESSAGE);\n        }\n        this.validateSchema(childSchema, schema);\n      });\n    };\n\n    if (schema.model.role === 'root') {\n      if (parentFlavour) {\n        throw new SchemaValidateError(\n          schema.model.flavour,\n          'Root block cannot have parent.'\n        );\n      }\n\n      validateChildren();\n      return;\n    }\n\n    if (!parentFlavour) {\n      throw new SchemaValidateError(\n        schema.model.flavour,\n        'Hub/Content must have parent.'\n      );\n    }\n\n    const parentSchema = this.flavourSchemaMap.get(parentFlavour);\n    if (!parentSchema) {\n      throw new SchemaValidateError(parentFlavour, SCHEMA_NOT_FOUND_MESSAGE);\n    }\n    this.validateSchema(schema, parentSchema);\n    validateChildren();\n  };\n\n  get versions() {\n    return Object.fromEntries(\n      Array.from(this.flavourSchemaMap.values()).map(\n        (schema): [string, number] => [schema.model.flavour, schema.version]\n      )\n    );\n  }\n\n  private _matchFlavour(childFlavour: string, parentFlavour: string) {\n    return (\n      minimatch(childFlavour, parentFlavour) ||\n      minimatch(parentFlavour, childFlavour)\n    );\n  }\n\n  private _validateParent(\n    child: BlockSchemaType,\n    parent: BlockSchemaType\n  ): boolean {\n    const _childFlavour = child.model.flavour;\n    const _parentFlavour = parent.model.flavour;\n\n    const childValidFlavours = child.model.parent || ['*'];\n    const parentValidFlavours = parent.model.children || ['*'];\n\n    return parentValidFlavours.some(parentValidFlavour => {\n      return childValidFlavours.some(childValidFlavour => {\n        if (parentValidFlavour === '*' && childValidFlavour === '*') {\n          return true;\n        }\n\n        if (parentValidFlavour === '*') {\n          return this._matchFlavour(childValidFlavour, _parentFlavour);\n        }\n\n        if (childValidFlavour === '*') {\n          return this._matchFlavour(_childFlavour, parentValidFlavour);\n        }\n\n        return (\n          this._matchFlavour(_childFlavour, parentValidFlavour) &&\n          this._matchFlavour(childValidFlavour, _parentFlavour)\n        );\n      });\n    });\n  }\n\n  private _validateRole(child: BlockSchemaType, parent: BlockSchemaType) {\n    const childRole = child.model.role;\n    const parentRole = parent.model.role;\n    const childFlavour = child.model.flavour;\n    const parentFlavour = parent.model.flavour;\n\n    if (childRole === 'root') {\n      throw new SchemaValidateError(\n        childFlavour,\n        `Root block cannot have parent: ${parentFlavour}.`\n      );\n    }\n\n    if (childRole === 'hub' && parentRole === 'content') {\n      throw new SchemaValidateError(\n        childFlavour,\n        `Hub block cannot be child of content block: ${parentFlavour}.`\n      );\n    }\n\n    if (childRole === 'content' && parentRole === 'root') {\n      throw new SchemaValidateError(\n        childFlavour,\n        `Content block can only be child of hub block or itself. But get: ${parentFlavour}.`\n      );\n    }\n  }\n\n  isValid(child: string, parent: string) {\n    const childSchema = this.flavourSchemaMap.get(child);\n    const parentSchema = this.flavourSchemaMap.get(parent);\n    if (!childSchema || !parentSchema) {\n      return false;\n    }\n    try {\n      this.validateSchema(childSchema, parentSchema);\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  register(blockSchema: BlockSchemaType[]) {\n    blockSchema.forEach(schema => {\n      BlockSchema.parse(schema);\n      this.flavourSchemaMap.set(schema.model.flavour, schema);\n    });\n    return this;\n  }\n\n  toJSON() {\n    return Object.fromEntries(\n      Array.from(this.flavourSchemaMap.values()).map(\n        (schema): [string, Record<string, unknown>] => [\n          schema.model.flavour,\n          {\n            role: schema.model.role,\n            parent: schema.model.parent,\n            children: schema.model.children,\n          },\n        ]\n      )\n    );\n  }\n\n  validateSchema(child: BlockSchemaType, parent: BlockSchemaType) {\n    this._validateRole(child, parent);\n\n    const relationCheckSuccess = this._validateParent(child, parent);\n\n    if (!relationCheckSuccess) {\n      throw new SchemaValidateError(\n        child.model.flavour,\n        `Block cannot have parent: ${parent.model.flavour}.`\n      );\n    }\n  }\n}\n"]}