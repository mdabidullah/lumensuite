{"version":3,"file":"base.js","sourceRoot":"","sources":["../../src/adapter/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { assertEquals } from '@blocksuite/global/utils';\n\nimport type { Doc } from '../store/index.js';\nimport type { AssetsManager } from '../transformer/assets.js';\nimport type { DraftModel, Job, Slice } from '../transformer/index.js';\nimport type {\n  BlockSnapshot,\n  DocSnapshot,\n  SliceSnapshot,\n} from '../transformer/type.js';\n\nimport { ASTWalkerContext } from './context.js';\n\nexport type FromDocSnapshotPayload = {\n  snapshot: DocSnapshot;\n  assets?: AssetsManager;\n};\nexport type FromBlockSnapshotPayload = {\n  snapshot: BlockSnapshot;\n  assets?: AssetsManager;\n};\nexport type FromSliceSnapshotPayload = {\n  snapshot: SliceSnapshot;\n  assets?: AssetsManager;\n};\nexport type FromDocSnapshotResult<Target> = {\n  file: Target;\n  assetsIds: string[];\n};\nexport type FromBlockSnapshotResult<Target> = {\n  file: Target;\n  assetsIds: string[];\n};\nexport type FromSliceSnapshotResult<Target> = {\n  file: Target;\n  assetsIds: string[];\n};\nexport type ToDocSnapshotPayload<Target> = {\n  file: Target;\n  assets?: AssetsManager;\n};\nexport type ToBlockSnapshotPayload<Target> = {\n  file: Target;\n  assets?: AssetsManager;\n};\nexport type ToSliceSnapshotPayload<Target> = {\n  file: Target;\n  assets?: AssetsManager;\n};\n\nexport abstract class BaseAdapter<AdapterTarget = unknown> {\n  job: Job;\n\n  get configs() {\n    return this.job.adapterConfigs;\n  }\n\n  constructor(job: Job) {\n    this.job = job;\n  }\n\n  async fromBlock(mode: DraftModel) {\n    try {\n      const blockSnapshot = await this.job.blockToSnapshot(mode);\n      if (!blockSnapshot) return;\n      return await this.fromBlockSnapshot({\n        snapshot: blockSnapshot,\n        assets: this.job.assetsManager,\n      });\n    } catch (error) {\n      console.error('Cannot convert block to snapshot');\n      console.error(error);\n      return;\n    }\n  }\n\n  abstract fromBlockSnapshot(\n    payload: FromBlockSnapshotPayload\n  ):\n    | Promise<FromBlockSnapshotResult<AdapterTarget>>\n    | FromBlockSnapshotResult<AdapterTarget>;\n\n  async fromDoc(doc: Doc) {\n    try {\n      const docSnapshot = await this.job.docToSnapshot(doc);\n      if (!docSnapshot) return;\n      return await this.fromDocSnapshot({\n        snapshot: docSnapshot,\n        assets: this.job.assetsManager,\n      });\n    } catch (error) {\n      console.error('Cannot convert doc to snapshot');\n      console.error(error);\n      return;\n    }\n  }\n\n  abstract fromDocSnapshot(\n    payload: FromDocSnapshotPayload\n  ):\n    | Promise<FromDocSnapshotResult<AdapterTarget>>\n    | FromDocSnapshotResult<AdapterTarget>;\n\n  async fromSlice(slice: Slice) {\n    try {\n      const sliceSnapshot = await this.job.sliceToSnapshot(slice);\n      if (!sliceSnapshot) return;\n      return await this.fromSliceSnapshot({\n        snapshot: sliceSnapshot,\n        assets: this.job.assetsManager,\n      });\n    } catch (error) {\n      console.error('Cannot convert slice to snapshot');\n      console.error(error);\n      return;\n    }\n  }\n\n  abstract fromSliceSnapshot(\n    payload: FromSliceSnapshotPayload\n  ):\n    | Promise<FromSliceSnapshotResult<AdapterTarget>>\n    | FromSliceSnapshotResult<AdapterTarget>;\n\n  async toBlock(\n    payload: ToBlockSnapshotPayload<AdapterTarget>,\n    doc: Doc,\n    parent?: string,\n    index?: number\n  ) {\n    try {\n      const snapshot = await this.toBlockSnapshot(payload);\n      if (!snapshot) return;\n      return await this.job.snapshotToBlock(snapshot, doc, parent, index);\n    } catch (error) {\n      console.error('Cannot convert block snapshot to block');\n      console.error(error);\n      return;\n    }\n  }\n\n  abstract toBlockSnapshot(\n    payload: ToBlockSnapshotPayload<AdapterTarget>\n  ): Promise<BlockSnapshot> | BlockSnapshot;\n\n  async toDoc(payload: ToDocSnapshotPayload<AdapterTarget>) {\n    try {\n      const snapshot = await this.toDocSnapshot(payload);\n      if (!snapshot) return;\n      return await this.job.snapshotToDoc(snapshot);\n    } catch (error) {\n      console.error('Cannot convert doc snapshot to doc');\n      console.error(error);\n      return;\n    }\n  }\n\n  abstract toDocSnapshot(\n    payload: ToDocSnapshotPayload<AdapterTarget>\n  ): Promise<DocSnapshot> | DocSnapshot;\n\n  async toSlice(\n    payload: ToSliceSnapshotPayload<AdapterTarget>,\n    doc: Doc,\n    parent?: string,\n    index?: number\n  ) {\n    try {\n      const snapshot = await this.toSliceSnapshot(payload);\n      if (!snapshot) return;\n      return await this.job.snapshotToSlice(snapshot, doc, parent, index);\n    } catch (error) {\n      console.error('Cannot convert slice snapshot to slice');\n      console.error(error);\n      return;\n    }\n  }\n\n  abstract toSliceSnapshot(\n    payload: ToSliceSnapshotPayload<AdapterTarget>\n  ): Promise<SliceSnapshot | null> | SliceSnapshot | null;\n}\n\ntype Keyof<T> = T extends unknown ? keyof T : never;\n\ntype WalkerFn<ONode extends object, TNode extends object> = (\n  o: NodeProps<ONode>,\n  context: ASTWalkerContext<TNode>\n) => Promise<void> | void;\n\ntype NodeProps<Node extends object> = {\n  node: Node;\n  next?: Node | null;\n  parent: NodeProps<Node> | null;\n  prop: Keyof<Node> | null;\n  index: number | null;\n};\n\n// Ported from https://github.com/Rich-Harris/estree-walker MIT License\nexport class ASTWalker<ONode extends object, TNode extends object | never> {\n  private _enter: WalkerFn<ONode, TNode> | undefined;\n\n  private _isONode!: (node: unknown) => node is ONode;\n\n  private _leave: WalkerFn<ONode, TNode> | undefined;\n\n  private _visit = async (o: NodeProps<ONode>) => {\n    if (!o.node) return;\n    this.context._skipChildrenNum = 0;\n    this.context._skip = false;\n\n    if (this._enter) {\n      await this._enter(o, this.context);\n    }\n\n    if (this.context._skip) {\n      return;\n    }\n\n    for (const key in o.node) {\n      const value = o.node[key];\n\n      if (value && typeof value === 'object') {\n        if (Array.isArray(value)) {\n          for (\n            let i = this.context._skipChildrenNum;\n            i < value.length;\n            i += 1\n          ) {\n            const item = value[i];\n            if (\n              item !== null &&\n              typeof item === 'object' &&\n              this._isONode(item)\n            ) {\n              const nextItem = value[i + 1] ?? null;\n              await this._visit({\n                node: item,\n                next: nextItem,\n                parent: o,\n                prop: key as unknown as Keyof<ONode>,\n                index: i,\n              });\n            }\n          }\n        } else if (\n          this.context._skipChildrenNum === 0 &&\n          this._isONode(value)\n        ) {\n          await this._visit({\n            node: value,\n            next: null,\n            parent: o,\n            prop: key as unknown as Keyof<ONode>,\n            index: null,\n          });\n        }\n      }\n    }\n\n    if (this._leave) {\n      await this._leave(o, this.context);\n    }\n  };\n\n  private context: ASTWalkerContext<TNode>;\n\n  setEnter = (fn: WalkerFn<ONode, TNode>) => {\n    this._enter = fn;\n  };\n\n  setLeave = (fn: WalkerFn<ONode, TNode>) => {\n    this._leave = fn;\n  };\n\n  setONodeTypeGuard = (fn: (node: unknown) => node is ONode) => {\n    this._isONode = fn;\n  };\n\n  walk = async (oNode: ONode, tNode: TNode) => {\n    this.context.openNode(tNode);\n    await this._visit({ node: oNode, parent: null, prop: null, index: null });\n    assertEquals(this.context.stack.length, 1, 'There are unclosed nodes');\n    return this.context.currentNode();\n  };\n\n  walkONode = async (oNode: ONode) => {\n    await this._visit({ node: oNode, parent: null, prop: null, index: null });\n  };\n\n  constructor() {\n    this.context = new ASTWalkerContext<TNode>();\n  }\n}\n"]}