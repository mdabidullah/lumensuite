{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../src/root-block/widgets/pie-menu/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { IVec } from '@blocksuite/global/utils';\n\nimport { ThemeObserver } from '@blocksuite/affine-shared/theme';\n\nimport type { EdgelessTool } from '../../edgeless/types.js';\nimport type {\n  ActionFunction,\n  IPieNodeWithAction,\n  PieColorNodeModel,\n  PieCommandNodeModel,\n  PieMenuContext,\n  PieNodeModel,\n  PieNonRootNode,\n  PieRootNodeModel,\n  PieSubmenuNodeModel,\n} from './base.js';\n\nimport { EdgelessRootBlockComponent } from '../../edgeless/edgeless-root-block.js';\nimport { ShapeToolController } from '../../edgeless/tools/shape-tool.js';\n\nexport function updateShapeOverlay(rootComponent: EdgelessRootBlockComponent) {\n  const controller = rootComponent.tools.currentController;\n  if (controller instanceof ShapeToolController) {\n    controller.createOverlay();\n  }\n}\n\nexport function getActiveShapeColor(type: 'fill' | 'stroke') {\n  return ({ rootComponent }: PieMenuContext) => {\n    if (rootComponent instanceof EdgelessRootBlockComponent) {\n      const props =\n        rootComponent.service.editPropsStore.lastProps$.value[\n          'shape:roundedRect'\n        ];\n      const color = type == 'fill' ? props.fillColor : props.strokeColor;\n      return ThemeObserver.getColorValue(color);\n    }\n    return '';\n  };\n}\n\nexport function getActiveConnectorStrokeColor({\n  rootComponent,\n}: PieMenuContext) {\n  if (rootComponent instanceof EdgelessRootBlockComponent) {\n    const props =\n      rootComponent.service.editPropsStore.lastProps$.value.connector;\n    const color = props.stroke;\n    return ThemeObserver.getColorValue(color);\n  }\n  return '';\n}\n\nexport function setEdgelessToolAction(tool: EdgelessTool): ActionFunction {\n  return ({ rootComponent }) => {\n    rootComponent.service.tool.setEdgelessTool(tool);\n  };\n}\n\nexport function getPosition(angleRad: number, v: IVec): IVec {\n  const x = Math.cos(angleRad) * v[0];\n  const y = Math.sin(angleRad) * v[1];\n  return [x, y];\n}\n\nexport function isNodeWithChildren(\n  node: PieNodeModel\n): node is PieNodeModel & { children: PieNonRootNode[] } {\n  return 'children' in node;\n}\n\nexport function isRootNode(model: PieNodeModel): model is PieRootNodeModel {\n  return model.type === 'root';\n}\n\nexport function isSubmenuNode(\n  model: PieNodeModel\n): model is PieSubmenuNodeModel {\n  return model.type === 'submenu';\n}\n\nexport function isCommandNode(\n  model: PieNodeModel\n): model is PieCommandNodeModel {\n  return model.type === 'command';\n}\n\nexport function isColorNode(model: PieNodeModel): model is PieColorNodeModel {\n  return model.type === 'color';\n}\n\nexport function isNodeWithAction(\n  node: PieNodeModel\n): node is IPieNodeWithAction {\n  return 'action' in node && typeof node.action === 'function';\n}\n\n//------------------------------------------------------------------------------------\n// credits: https://github.com/kando-menu/kando/blob/main/src/renderer/math/index.ts\n//------------------------------------------------------------------------------------\nexport function calcNodeAngles(\n  node: { angle?: number }[],\n  parentAngle?: number\n): number[] {\n  const nodeAngles: number[] = [];\n\n  // Shouldn't happen, but who knows...\n  if (node.length == 0) {\n    return nodeAngles;\n  }\n\n  // We begin by storing all fixed angles.\n  const fixedAngles: { angle: number; index: number }[] = [];\n  node.forEach((item, index) => {\n    if (item.angle && item.angle >= 0) {\n      fixedAngles.push({ angle: item.angle, index: index });\n    }\n  });\n\n  // Make sure that the parent link does not collide with a fixed item. For now, we\n  // just move the fixed angle a tiny bit. This is somewhat error-prone as it may\n  // collide with another fixed angle now. Maybe this could be solved in a better way?\n  // Maybe some global minimum angular spacing of items?\n  if (parentAngle != undefined) {\n    for (let i = 0; i < fixedAngles.length; i++) {\n      if (Math.abs(fixedAngles[i].angle - parentAngle) < 0.0001) {\n        fixedAngles[i].angle += 0.1;\n      }\n    }\n  }\n\n  // Make sure that the fixed angles are between 0째 and 360째.\n  for (let i = 0; i < fixedAngles.length; i++) {\n    fixedAngles[i].angle = fixedAngles[i].angle % 360;\n  }\n\n  // Make sure that the fixed angles increase monotonically. If a fixed angle is larger\n  // than the next one, the next one will be ignored.\n  for (let i = 0; i < fixedAngles.length - 1; ) {\n    if (fixedAngles[i].angle > fixedAngles[i + 1].angle) {\n      fixedAngles.splice(i + 1, 1);\n    } else {\n      ++i;\n    }\n  }\n\n  // If no item has a fixed angle, we assign one to the first item. If there is no\n  // parent item, this is on the top (0째). Else, the angular space will be evenly\n  // distributed to all child items and the first item will be at the first possible\n  // location with an angle > 0.\n  if (fixedAngles.length == 0) {\n    let firstAngle = 0;\n    if (parentAngle != undefined) {\n      const wedgeSize = 360 / (node.length + 1);\n      let minAngle = 360;\n      for (let i = 0; i < node.length; i++) {\n        minAngle = Math.min(\n          minAngle,\n          (parentAngle + (i + 1) * wedgeSize) % 360\n        );\n      }\n      firstAngle = minAngle;\n    }\n    fixedAngles.push({ angle: firstAngle, index: 0 });\n    nodeAngles[0] = firstAngle;\n  }\n\n  // Now we iterate through the fixed angles, always considering wedges between\n  // consecutive pairs of fixed angles. If there is only one fixed angle, there is also\n  // only one 360째-wedge.\n  for (let i = 0; i < fixedAngles.length; i++) {\n    const wedgeBeginIndex = fixedAngles[i].index;\n    const wedgeBeginAngle = fixedAngles[i].angle;\n    const wedgeEndIndex = fixedAngles[(i + 1) % fixedAngles.length].index;\n    let wedgeEndAngle = fixedAngles[(i + 1) % fixedAngles.length].angle;\n\n    // The fixed angle can be stored in our output.\n    nodeAngles[wedgeBeginIndex] = wedgeBeginAngle;\n\n    // Make sure we loop around.\n    if (wedgeEndAngle <= wedgeBeginAngle) {\n      wedgeEndAngle += 360;\n    }\n\n    // Calculate the number of items between the begin and end indices.\n    let wedgeItemCount =\n      (wedgeEndIndex - wedgeBeginIndex - 1 + node.length) % node.length;\n\n    // We have one item more if the parent link is inside our wedge.\n    let parentInWedge = false;\n\n    if (parentAngle != undefined) {\n      // It can be that the parent link is inside the current wedge, but it's angle is\n      // one full turn off.\n      if (parentAngle < wedgeBeginAngle) {\n        parentAngle += 360;\n      }\n\n      parentInWedge =\n        parentAngle > wedgeBeginAngle && parentAngle < wedgeEndAngle;\n      if (parentInWedge) {\n        wedgeItemCount += 1;\n      }\n    }\n\n    // Calculate the angular difference between consecutive items in the current wedge.\n    const wedgeItemGap =\n      (wedgeEndAngle - wedgeBeginAngle) / (wedgeItemCount + 1);\n\n    // Now we assign an angle to each item between the begin and end indices.\n    let index = (wedgeBeginIndex + 1) % node.length;\n    let count = 1;\n    let parentGapRequired = parentInWedge;\n\n    while (index != wedgeEndIndex) {\n      let itemAngle = wedgeBeginAngle + wedgeItemGap * count;\n\n      // Insert gap for parent link if required. for connector\n      if (\n        parentGapRequired &&\n        itemAngle + wedgeItemGap / 2 - (parentAngle ?? 0) > 0\n      ) {\n        count += 1;\n        itemAngle = wedgeBeginAngle + wedgeItemGap * count;\n        parentGapRequired = false;\n      }\n\n      nodeAngles[index] = itemAngle % 360;\n\n      index = (index + 1) % node.length;\n      count += 1;\n    }\n  }\n\n  return nodeAngles;\n}\n\nexport function calcNodeWedges(\n  nodeAngles: number[],\n  parentAngle?: number\n): { start: number; end: number }[] {\n  // This should never happen, but who knows...\n  if (nodeAngles.length === 0 && parentAngle === undefined) {\n    return [];\n  }\n\n  // If the node has a single child but no parent (e.g. it's the root node), we can\n  // simply return a full circle.\n  if (nodeAngles.length === 1 && parentAngle === undefined) {\n    return [{ start: 0, end: 360 }];\n  }\n\n  // If the node has a single child and a parent, we can set the start and end\n  // angles to the center angles.\n  if (nodeAngles.length === 1 && parentAngle !== undefined) {\n    let start = parentAngle;\n    let center = nodeAngles[0];\n    let end = parentAngle + 360;\n\n    [start, center, end] = normalizeConsecutiveAngles(start, center, end);\n    [start, end] = scaleWedge(start, center, end, 0.5);\n\n    return [{ start: start, end: end }];\n  }\n\n  // In all other cases, we loop through the items and compute the wedges. If the parent\n  // angle happens to be inside a wedge, we crop the wedge accordingly.\n  const wedges: { start: number; end: number }[] = [];\n\n  for (let i = 0; i < nodeAngles.length; i++) {\n    let start = nodeAngles[(i + nodeAngles.length - 1) % nodeAngles.length];\n    let center = nodeAngles[i];\n    let end = nodeAngles[(i + 1) % nodeAngles.length];\n\n    [start, center, end] = normalizeConsecutiveAngles(start, center, end);\n\n    if (parentAngle !== undefined) {\n      [start, end] = cropWedge(start, center, end, parentAngle);\n      [start, center, end] = normalizeConsecutiveAngles(start, center, end);\n    }\n\n    [start, end] = scaleWedge(start, center, end, 0.5);\n\n    wedges.push({ start: start, end: end });\n  }\n\n  return wedges;\n}\nexport function isAngleBetween(\n  angle: number,\n  start: number,\n  end: number\n): boolean {\n  return (\n    (angle > start && angle <= end) ||\n    (angle - 360 > start && angle - 360 <= end) ||\n    (angle + 360 > start && angle + 360 <= end)\n  );\n}\n\nfunction normalizeConsecutiveAngles(\n  start: number,\n  center: number,\n  end: number\n) {\n  while (center < start) {\n    center += 360;\n  }\n\n  while (end < center) {\n    end += 360;\n  }\n\n  while (center >= 360) {\n    start -= 360;\n    center -= 360;\n    end -= 360;\n  }\n\n  return [start, center, end];\n}\n\nfunction cropWedge(\n  start: number,\n  center: number,\n  end: number,\n  cropAngle: number\n) {\n  if (isAngleBetween(cropAngle, start, center)) {\n    start = cropAngle;\n  }\n\n  if (isAngleBetween(cropAngle, center, end)) {\n    end = cropAngle;\n  }\n\n  return [start, end];\n}\nfunction scaleWedge(start: number, center: number, end: number, scale: number) {\n  start = center - (center - start) * scale;\n  end = center + (end - center) * scale;\n\n  return [start, end];\n}\n"]}