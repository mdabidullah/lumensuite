{"version":3,"file":"utils.js","sourceRoot":"","sources":["../../../../src/root-block/widgets/doc-remote-selection/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import type { DirectiveResult } from 'lit/directive.js';\n\nimport { styleMap, type StyleMapDirective } from 'lit/directives/style-map.js';\n\nimport type { SelectionRect } from './doc-remote-selection.js';\n\nexport function selectionStyle(\n  rect: SelectionRect,\n  color: string\n): DirectiveResult<typeof StyleMapDirective> {\n  return styleMap({\n    position: 'absolute',\n    width: `${rect.width}px`,\n    height: `${rect.height}px`,\n    top: `${rect.top}px`,\n    left: `${rect.left}px`,\n    backgroundColor: rect.transparent ? 'transparent' : color,\n    pointerEvent: 'none',\n    opacity: '20%',\n    borderRadius: '3px',\n  });\n}\n\nexport function cursorStyle(\n  rect: SelectionRect,\n  color: string\n): DirectiveResult<typeof StyleMapDirective> {\n  return styleMap({\n    position: 'absolute',\n    width: `${rect.width}px`,\n    height: `${rect.height}px`,\n    top: `${rect.top}px`,\n    left: `${rect.left}px`,\n    backgroundColor: color,\n    pointerEvent: 'none',\n  });\n}\n\nfunction covers(rect1: SelectionRect, rect2: SelectionRect): boolean {\n  return (\n    rect1.left <= rect2.left &&\n    rect1.top <= rect2.top &&\n    rect1.left + rect1.width >= rect2.left + rect2.width &&\n    rect1.top + rect1.height >= rect2.top + rect2.height\n  );\n}\n\nfunction intersects(rect1: SelectionRect, rect2: SelectionRect): boolean {\n  return (\n    rect1.left <= rect2.left + rect2.width &&\n    rect1.left + rect1.width >= rect2.left &&\n    rect1.top <= rect2.top + rect2.height &&\n    rect1.top + rect1.height >= rect2.top\n  );\n}\n\nfunction merge(rect1: SelectionRect, rect2: SelectionRect): SelectionRect {\n  const left = Math.min(rect1.left, rect2.left);\n  const top = Math.min(rect1.top, rect2.top);\n  const right = Math.max(rect1.left + rect1.width, rect2.left + rect2.width);\n  const bottom = Math.max(rect1.top + rect1.height, rect2.top + rect2.height);\n\n  return {\n    left: left,\n    top: top,\n    width: right - left,\n    height: bottom - top,\n  };\n}\n\nexport function filterCoveringRects(rects: SelectionRect[]): SelectionRect[] {\n  let mergedRects: SelectionRect[] = [];\n  let hasChanges: boolean;\n\n  do {\n    hasChanges = false;\n    const newMergedRects: SelectionRect[] = [...mergedRects];\n\n    for (const rect of rects) {\n      let merged = false;\n\n      for (let i = 0; i < newMergedRects.length; i++) {\n        if (covers(newMergedRects[i], rect)) {\n          merged = true;\n          break;\n        } else if (intersects(newMergedRects[i], rect)) {\n          newMergedRects[i] = merge(newMergedRects[i], rect);\n          merged = true;\n          hasChanges = true;\n          break;\n        }\n      }\n\n      if (!merged) {\n        newMergedRects.push(rect);\n      }\n    }\n\n    if (!hasChanges) {\n      for (let i = 0; i < newMergedRects.length; i++) {\n        for (let j = i + 1; j < newMergedRects.length; j++) {\n          if (intersects(newMergedRects[i], newMergedRects[j])) {\n            newMergedRects[i] = merge(newMergedRects[i], newMergedRects[j]);\n            newMergedRects.splice(j, 1);\n            hasChanges = true;\n            break;\n          }\n        }\n      }\n    }\n\n    mergedRects = newMergedRects;\n  } while (hasChanges);\n\n  return mergedRects;\n}\n"]}