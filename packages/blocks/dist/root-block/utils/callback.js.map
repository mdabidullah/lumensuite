{"version":3,"file":"callback.js","sourceRoot":"","sources":["../../../src/root-block/utils/callback.ts"],"names":[],"mappings":"AAIA,OAAO,EAAE,gBAAgB,EAAE,MAAM,yCAAyC,CAAC;AAE3E,MAAM,CAAC,KAAK,UAAU,kBAAkB,CACtC,UAAsB,EACtB,KAAiB,EACjB,QAAmC;IAEnC,MAAM,QAAQ,GAAG,MAAM,gBAAgB,CAAC,UAAU,EAAE,KAAK,CAAC,EAAE,CAAC,CAAC;IAC9D,IAAI,CAAC,QAAQ,EAAE,CAAC;QACd,OAAO,CAAC,KAAK,CAAC,4BAA4B,CAAC,CAAC;QAC5C,OAAO;IACT,CAAC;IACD,MAAM,QAAQ,CAAC,cAAc,CAAC;IAC9B,MAAM,YAAY,GAAG,QAAQ,CAAC,YAAY,CAAC;IAC3C,IAAI,CAAC,YAAY,EAAE,CAAC;QAClB,OAAO,CAAC,KAAK,CAAC,iCAAiC,CAAC,CAAC;QACjD,OAAO;IACT,CAAC;IACD,YAAY,CAAC,KAAK,CAAC,cAAc,CAAC,IAAI,CAAC,GAAG,EAAE;QAC1C,IAAI,QAAQ,EAAE,CAAC;YACb,QAAQ,CAAC,QAAQ,CAAC,CAAC;QACrB,CAAC;IACH,CAAC,CAAC,CAAC;AACL,CAAC;AAED,oDAAoD;AACpD,uFAAuF;AACvF,mCAAmC;AACnC,6CAA6C;AAC7C,mCAAmC;AACnC,MAAM,CAAC,KAAK,UAAU,qBAAqB,CACzC,UAAsB,EACtB,KAAiB,EACjB,QAAyC;IAEzC,MAAM,IAAI,GAAG,KAAK,CAAC,GAAG,CAAC;IACvB,IAAI,CAAC,IAAI,CAAC,IAAI;QAAE,OAAO;IAEvB,MAAM,aAAa,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;IAC7D,IAAI,CAAC,aAAa;QAAE,OAAO;IAC3B,MAAM,aAAa,CAAC,cAAc,CAAC;IAEnC,MAAM,OAAO,GAAG,UAAU,CAAC,IAAI,CAAC,QAAQ,CAAC,KAAK,CAAC,EAAE,CAAC,CAAC;IACnD,IAAI,OAAO;QAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;AACjC,CAAC","sourcesContent":["import type { RichText } from '@blocksuite/affine-components/rich-text';\nimport type { BlockComponent, EditorHost } from '@blocksuite/block-std';\nimport type { BlockModel } from '@blocksuite/store';\n\nimport { asyncGetRichText } from '@blocksuite/affine-components/rich-text';\n\nexport async function onModelTextUpdated(\n  editorHost: EditorHost,\n  model: BlockModel,\n  callback?: (text: RichText) => void\n) {\n  const richText = await asyncGetRichText(editorHost, model.id);\n  if (!richText) {\n    console.error('RichText is not ready yet.');\n    return;\n  }\n  await richText.updateComplete;\n  const inlineEditor = richText.inlineEditor;\n  if (!inlineEditor) {\n    console.error('Inline editor is not ready yet.');\n    return;\n  }\n  inlineEditor.slots.renderComplete.once(() => {\n    if (callback) {\n      callback(richText);\n    }\n  });\n}\n\n// Run the callback until a model's element updated.\n// Please notice that the callback will be called **once the element itself is ready**.\n// The children may be not updated.\n// If you want to wait for the text elements,\n// please use `onModelTextUpdated`.\nexport async function onModelElementUpdated(\n  editorHost: EditorHost,\n  model: BlockModel,\n  callback: (block: BlockComponent) => void\n) {\n  const page = model.doc;\n  if (!page.root) return;\n\n  const rootComponent = editorHost.view.getBlock(page.root.id);\n  if (!rootComponent) return;\n  await rootComponent.updateComplete;\n\n  const element = editorHost.view.getBlock(model.id);\n  if (element) callback(element);\n}\n"]}